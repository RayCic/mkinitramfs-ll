# $Header: mkinitramfs-ll/README,v 0.4.0 2011/11/25 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
#
#	OPTIONAL ARGUMENTS [ONLY iroot IS REQUIRED else nothing will happen but maybe a kernel panic] 
#	and	of course when using this script, one does not need root=<arg> nor resume=<arg>.
#	init script supports the following specific arguments: 
#		* iroot=<PV|VG-LV>[:c:<fs>:n]    required root device, recommanded optinal `:c:ext4' for an 
# 		                                 ext4 rootfs, last `:n' disable a `die' after fsck failure. 
#		* [imtopt=<ro,inode64,...>]      optional mount options for rootfs.
#		* [imod=<drm,ttm,...,nouveau>]   optional modules [list] to load (in the boot group).
#		* ikmap=<kmap>[:<font>]          optional keymap and font to load, may be handy for passwords.
#		* ishrl=<n>|:<n>                 interrupts init and drops to n level or pass n to real init.
#		* rescue                         drops directly into a minimal shell.
#		* ilvm=<map-PV>,...,<map-PV>     LVM2 argument <mapping-PV> is collon `:' separated list of PVs
#		                                 of a VG; and comma `,' separated list of VG: 1st for root, 2nd 
#		                                 for swap and the 3rd for resume, hence one can append enough 
#		                                 commas to asign a particular group and nothing for the others.
#
#		* iswap=<type>:<VG-LV>[:signature]              e.g. iswap=swap:sda2 for a swap device.
#		* iresume=<type>:<VG-LV>[:signature]            e.g. iresume=file:<VG-LV>:0x4400 for a swapfile.
#		* ikroot=<mode>:<device>:</path/to/file>        ikroot for [i]root keyfile or [no-]password.
#		* ikswap=<mode>:<device>:</path/to/file>        iswap for [i]swap keyfile or [no-]password.
#		* ikresume=<mode>:<device>:</path/to/key/file>  same as above but for [i]resume.
#
#		* isqfsd=y[|/sqfsdir],y[|[n|a]:<dir>]           squashed directories, see below for more info.    
#
#	== About device, `/dev/' prefix and detached [LUKS] header ==
#	There's no need to provide any `/dev/' prefix for block devices, find_blkd() will take care of it.
#
#	Now one can use UUID="<uuid>" or LABEL="<label>" instead of [/dev/]sd<CHAR> for any device or PV. 
#
#	However, a leading slash `/' is used as a separator for detached header device|file when using 
#	LUKS: `<map-UUID="<uid>"[|LABEL="<label>"][/[dev/]sd<CHAR>[|</path/to/header>]]'
#	
#	Each encrypted PV, with a detached header is given like:
#	   * <sda6/[dev/]sdc> for a detached header to `/dev/sdc' device [passed as `--header /dev/sdc']
#	   * <sdb/path/to/header/file> for a detached header file [`--header /mnt/tok/path/to/header/file'] 
#	     so in this case, the header file must be in the same removable device or `/boot' PV used for 
#	     keyfiles [because it'll be too troublesome otherwise]. Of course, a detached header to a device 
#	     can use UUID or LABEL instead of `/sd<CHAR>[0-9]' which is recommanded to avoid header mismatch!
#
#	== About LVM2 argument ==
#	Actually a PV in a group, respectively root, swap, resume is given by <mapping>-<device>, 
#	mapping being a mapping name for cryptsetup and a block device|partition without the `/dev/' prefix.
#
#	   <LV|PV|VG>  - <Logical|Physical Volume|Volume Group>.
#	   <VG-LV>     - <Volume Group name-Logical Volume name>
#	   <map-PV>    - comma separated list <mapping-PV> e.g. <pv1-sda1,pv2-sdb1,...> for a Volume Group,
#	                 the 1st being for root, the 2nd for swap and the 3rd for resume. 
#	                 So this `ilvm=,swp-sdc1,' asign a VG for swap VG only.
#	   NEW!
#	   NOTE, for unencrypted PVs, there's no need to provide a list of PVs in ilvm argument. A single 
#	   character or word is enough to activate LVM like `ilvm=y' for root.
#
#	   PV list     - now <map-PV> [list] can be replaced with </path/to/list> file, this require the 
#	                 use of keyfile to decrypt PV, which means that a removable media or `/boot' 
#	                 device is mounted. List can be a line separated list insted of a collon `:' list 
#	                 of the forme <mapping-UUID="<uid>"[/UUID="<uuid>"] for an UUID list. One can mix 
#	                 UUID, LABEL and [h|s]d[a-z][0-9] in a list. However, it's best to use UUID only 
#	                 for detached header from cypthertext device which prevent header mismatch. 
#	                 One can use multiple lists up to three, one for each group.
#
#	== About mount options ==
#	imtopt=<rootfs mount options>
#	Say, you have a rootfs=xfs|jsf|reiser|ext* and want to mount your rootfs with specific opts. 
#	In case of xfs, for exemple, just create your log LV on a different PV than what you're logging 
#	from and everything is set up--well if the logging LV is in the swap VG--and, in fact, you do 
#	not need a swap LV there--you just use that VG as if there were one. 
#
#	== About key files|modes ==
#	For partitions or PVs that are encrypted with a key, setting 'ikroot' and/or 'ikswap' and/or 
#	'ikresume' is required, otherwise a passphrase is required for *each* PV as fall back.
#	This information is then used to obtain each key file from the specified removable media if any. 
#
#		<mode>          - defines how the init script shall treat the supplied keyfile (see below). 
#		Supported modes:
#			* gpg 	-> keyfile is GnuPG-protected
#			* ldk 	-> keyfile is LUKS encrypted, via loop back device.
#			* reg 	-> keyfile is regular file
#			* pwd 	-> encrypted on a regular passphrase, if no argument is passed, fallback is pwd mode.
#			* none  -> handy for unencrypted PVs, with or without LVM2 support.
#
#		<device|dev>    - device or PV that will be assigned to the removable media e.g. sd[a-z][0-9]
#		</path/to/file> - full path to file inside the removable media.
#
#	== About squashed directories ==
#	One can use squashfs+aufs2 to squash directories like $PORTDIR:var/lib/layamn, or system related 
#	directories like usr:lib32:lib64:bin:sbin. Advantages are system speed/responsiveness.
#	
#	Squashed directories argument:
#		* isqfsd=y[|/sqfsdir],y[|[n|a]:<dir1>:<dirn>]	
#				- one can use uv_sqfsd and uv_sqfsdir or append directories after a `[n|a]:' for sqfsd.
#		* isqfsd=/sqfsdir,n:<dir 1>:<dir n>	
#				- neither uv_sqfsdir nor uv_sqfsd is used, appending sqfsdir and sqfsd dirs is required.
#		* isqfsd=y,y				
#				- using uv_sqfsd and uv_sqfsdir default values do not require any additional argument. 
#		* isqfsd=y,a:<dir 1>[:<dir n>]		
#				- same as above, however, <dir 1>[:<dir n>] is  appended to sqfsd variable.
#
#	NOTE: leading `/' slash is only required for [uv_|]sqfsdir, else mounting squashed dirs will fail. 
#
#	== Notes on key modes ==
#		* [gpg] encrypted key-file:
#				now gpg mode works quite well with... tested with 1.4.11, passed as `gpg -qd ...'; 2.0 seems 
#				to rquire too much trouble; `/usr/share/gnupg/options.skel' is required, additionally, one 
#				can add a `/.gnupg/gpg.conf' in the initramfs root to avoid its creattion on each reboot. 
#		* [ldk] encrypted key-file: 
#				passed to cryptsetup as `-d /dev/mapper/$(basename /path/to/keyfile)' after being decrypted. 
#		* [reg] regular key-file: 
#				will be passed to cryptsetup as `-d /path/to/keyfile'.
#		* [pwd] regular passphrase: 
#				it's not mandatory to append any `ik*=pwd' in the cmdline for this mode is the fallback.
#		* [none] unencrypted Physical Volume or device: 
#				it should be explicitely appended ikroot,ikswap or ikresume. I added this mode first for 
#				testing purpose for those, like me, who have a working system before encrypting rootfs.
#	
#	WARNING: Back up your data! else... you may lose a few of... them by carelessness.
# 
# 	== Kernel parameters example ==
#		* Root--no key--unencrypted PV: iroot=sda3 ikroot=none ikmap=es-cp850_i686.bin    
#		* Root--key regular passphrase--plus fbsplash: iroot=sda3 ikroot=pwd \
#			video=uvesafb:ywrap,1280x800-24@60 splash=verbose,theme:livecd-20007.0 console=tty1
#		* Root--regular keyfile on usb stick: iroot=sda3 ikroot=reg:sdb1:/path/to/keyfile
#		* Root--gpg encrypted key on usb stick: iroot=sda3 ikroot=gpg:sdb1:/path/to/file
#		* Swap and root--ldk encrypted keyfiles: iroot=sda3 iswap=swap[|file]:sda2[:signature] \
#			ikroot=ldk:sdb1:/path/to/rootkey ikswap=ldk:sdb1:/path/to/swapkey
#   	* Regular swap--AND TuxOnIce resume on a different PV--regular passphrase: 
#			iswap=swap:sda2 iresume=swap:sda3:0x4400 ikswap=pwd ikresume=pwd
#		* Swap file--resuming from hibernation--ldk protected keyfile on usb stick:
#			iswap=file:sda3:0x4400 iresume=toi[|CHAR|WORD] ikswap=ldk:sdb1:/path/to/swapkey
#	    
#	NOTE: For ldk mode I use a single LUKS encrypted keyfile to decrypt rootfs, PV|LV host of a swapfile.
#	One can use multiple LUKS encrypted keyfile if one want to, or even type a pwd for each PV, however, 
#	this will take some time. Now LVM2...
#
#		* Crypted LVs [root,swap] using LVM2--ldk crypted keyfile and--plus mount options for rootfs:
#			iroot=vgr-lvr iswap=file:vgs-lvs:0x4400 imtopt=logdev=/dev/mapper/vgs-lvl,inode64,barrier \
#			ilvm=pva1-UUID=<uuid>:pvb2-UUID=<uuid>,pvc1-UID=<uuid> \
#			ikroot=ldk:LABEL=PENDRIVE:/path/to/keyfile ikswap=ldk:LABEL=PENDRIVE:/path/to/keyfile
#
#	== Modules == 	
# 	If one need to load modules, create the groups you need in /etc/modules/ (inside initramfs),each file 
# 	should be a list of the modules, and each file name denotes the step in the init where they're loaded.
#		Supported groups:
#			* boot         - boot time modules loaded but not removed.
#			* tuxonice     - tuxonice module, wich aren't removed if you don't comment in a line.
#			* remdev       - modules required to access removable device
#			* gpg          - modules required to access gpg protected file.
#			* sqfsd        - modules required for squashfs+aufs2, you can still build them into the kernel.
#
#		Modules should exist on `/lib/modules/$KV/', like in your system.
#		Your kernel has to support module unloading for rmmod to work.
#
#	== User scripts execution ==
#	Now one can add scripts to `/etc/local.d' of the initramfs, or `$gitdir/misc' if using mkifs-ll 
#	building script. Each script should have a `.sh' sufix and a `$ishrl' prefix as the follwing[in []]:
#	   * [runlevel] 1: boot and cmdline modules, keymap, font -> [1] -> print msg;
#	   * [runlevel] 2: before... [2s] -> swap / [2r] -> resume;
#	   * [runlevel] 3: before... [3d] -> decrypt / [3f] -> fsck / [3m] -> mount root;
#	   * [runlevel] 4: before... [4c] -> clean up / [4u] -> umount / [4s] -> switch root.
#
# vim:fenc=utf-8:ci:pi:sts=0:sw=3:ts=3:
