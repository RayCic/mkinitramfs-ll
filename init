#!/bin/sh
# $Header: mkinitramfs-ll/init,v 0.6.0 2012/05/15 14:40:39 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.
#
# user defined variables
uv_init=/sbin/init      # init to execute after switching to real root
uv_root_map=root        # self descriptive
uv_check_env=0          # test if busybox/applets and the other binaries exist 
uv_sqfsdir=/sqfsd       # squashed source dir related variable
uv_sqfsd=usr:opt:bin:sbin:lib32	# squashed dirs variable
# default values [edit at your own risk]
gv_splashd=1
gv_splash=verbose
gv_shrl=0
# functions
info() 	{ echo -ne "\033[1;32m* \033[0m$@\n"; }
warn() 	{ echo -ne "\033[1;33m* \033[0m$@\n"; }
error() { echo -ne "\033[1;31m* \033[0m$@\n"; }

die() {
	umount -ln /mnt/tok &>/dev/null
	[ "${gv_splash}" == "silent" ] || verbose
	error "$@"
	info "Dropping you into a minimal shell..."
	for lk in ${gv_lkey}; do dmclose "${lk}"; done
	for ld in ${gv_ldev}; do losetup -d ${ld}; done
	exec sh
}

bchk() {
	for dir in /bin /sbin /usr/bin /usr/sbin; do
		[ -f "${dir}/${1}" ] && return
	done
}

achk() {
	if [ -e "/etc/applets" ]; then	
		for app in $(cat /etc/applets); do 
			[ -h ${app} ] || /bin/busybox --install -s && break
		done
	else busybox --install -s
		info "There's no /etc/applets, installing symlinks."
	fi
}

_rmmod() {
	if [ -f "/etc/modules/${1}" ]; then
		for mod in $(cat /etc/modules/${1}); do 
			rmmod $(echo ${mod}|sed 's/-/_/g') &> /dev/null
		done
	fi
}

_modprobe() {
	if [ -f "/etc/modules/${1}" ]; then
		for mod in $(cat /etc/modules/${1}); do 
			modprobe ${mod} &> /dev/null
		done
	fi
}

scmd() { [ $gv_splashd ] && echo "$@" >/lib/splash/cache/.splash; }
verbose() { scmd "set mode verbose"; }
silent() { scmd "set mode silent"; }
smsg() { scmd "set message $@"; scmd "repaint"; }

spalshd_init() {
	[ ${uv_check_env} ] || bchk "splash_util" "--"
	[ -n "$(echo ${gv_stty} | grep /dev)" ] || gv_stty="/dev/${gv_stty}"
	[ -n "${gv_stty}" ] && exec < ${gv_stty} > ${gv_stty} &>/dev/null
	[ -e /lib/splash/cache ] || mkdir -p /lib/splash/cache
	[ -e /lib/splash/cache/.splash ] || mknod /lib/splash/cache/.splash p
	splash_util --daemon "--theme=${gv_splash_theme}"
	gv_splashd=0
}

splashd_stop() { [ "${gv_splashd}" ] && gv_splashd=1 scmd "exit"; }

ishrl() {
	if [ "${gv_shrl}" == "${1}" ]; then verbose
		info "Shell runlevel: ${1}"
		local lv_scr="$(ls /etc/local.d/${1}?-*.sh &>/dev/null)"
		if [ -n "${lv_scr}" ]; then
			for scr in ${lv_scr}; do 
				info "executing ${scr}..."
				${scr} || warn "${scr} failed"
			done
		fi
		exec sh
	fi
}

_blkid() { echo $(blkid | grep "${1#*=}" | cut -d':' -f1); }

getldkey() {
	local lv_fname="${1##*/}"
	if [ ! "${gv_crypt_loop}" ]; then
		local lv_ldev="$(losetup -f)" || die "failed to create loop back devices"
		losetup ${lv_ldev} ${1} || die "failed to setup losetup"
		gv_ldev="${lv_ldev}:${gv_ldev}"
	fi
	cryptsetup luksOpen "${lv_ldev}" "${lv_fname}" 
	if [ "$?" ]; then
		gv_kfile=/dev/mapper/"${lv_fname}"
		gv_lkey="${lv_fname}:${gv_lkey}"
	fi
}

getkey() {
	local lv_kmode="${1}"
	if [ -n "${lv_kmode}" ]; then 
		if [ "${lv_kmode}" != "none" ];then
			if [ -z "${gv_crypt_loop}" ]; then
				local lv_version=$(cryptsetup --version | awk '{ print $2 }')
				[ $(echo "${lv_version}" | cut -d'.' -f2) -ge 3 ] && gv_crypt_loop=0
				[ $(echo "${lv_version}" | cut -d'.' -f2) -ge 4 ] && gv_crypt_header=0
			fi
		else return; fi
	else return; fi
	if [ "${lv_kmode}" != "pwd" ]; then
		[ -n "${2}" ] || die "ik${4}=${1}:${2}:${3} device field empty."
		[ -n "${3}" ] || die "ik${4}=${1}:${2}:${3} filepath field empty."
		local lv_dev=$(_blkid "${2}"); gv_fpath="${3}"
		if [ -z "$(mount | grep /mnt/tok)" ]; then
			if [ ! -b "${lv_dev}" ]; then
				sleep 2; lv_dev=$(_blkid "${2}")
				if [ ! -b "${lv_dev}" ]; then
					info "Insert removable device and press Enter."
					read; sleep 2; lv_dev=$(_blkid "${2}")
				fi
				while [ ! -b "${lv_dev}" ]; do
					info "${lv_dev} does not exist, input a valid dev name"
					info "e.g. '[/dev/]sdb1', 'LABEL=<label>' 'UUID=<uuid>'"
					read lv_dev; sleep 2; lv_dev=$(_blkid "${lv_dev}")
				done
			fi
			mount -n -r "${lv_dev}" /mnt/tok &> /dev/null || \
				die "Failed to mount ${lv_dev} remdev."
			info "Removable device mounted."
		fi
		[ -f "/mnt/tok/${gv_fpath}" ] || \
			die "${gv_fpath} keyfile does not exist in ${lv_dev} remdev."
	fi
	case ${lv_kmode} in
		gpg) [ ${uv_check_env} ] || bchk "gpg" "--"
			 gv_kfile="/mnt/tok/${gv_fpath}"; gv_cmode=gpg;;
		reg) gv_kfile="/mnt/tok/${gv_fpath}"; gv_cmode=reg;;
		ldk) [ -e "/dev/mapper/${gv_fname}" ] || \
			 getldkey "/mnt/tok/${gv_fpath}"; gv_cmode=ldk;;
		pwd) gv_cmode=pwd;;
		*)   die "${lv_kmode}:mode is not valid.";; 
	esac
}

dmclose() { 
	[ -n "${2}" ] && vgchange -an ${2%-*} &>/dev/null
	local IFS="${IFS}:" 
	for pv in ${1}; do 
		warn "disabling ${pv%/*}..."
		cryptsetup luksClose ${1%%-*} || cryptsetup remove ${1%%-*} || \
		warn "${1%/*}: failed to close mapping."
	done
}

dmcrypt() {
	info "Type a valid LUKS cipher:hash, default is 'aes-xts-plain:sha256'"
	info "you can take something safer like 'aes-cbc-essiv:sha256'"
	read local lv_cph
	info "Type a valide key-size [256|512], default is 256 bits:"
	read local lv_ksz
	if [ -e "${gv_kfile}" ]; then 
		info "Do you want to use the existing ${gv_kfile} key-file? [NO|yes]"
		read local lv_ukf
		[ "${lv_ukf:-no}" = "yes" ] && lv_ukf="-d ${lv_ukf}" || lv_ukf=
	fi
	if [ -n "${lv_header}" ]; then info "Do you want to use ${lv_header} [NO|yes]?"
		lv_asw=; read lv_asw
		if [ "${lv_asw:-no}" = "yes" ]; then info "Enter a valid aligh-payload offset,"
			info "option is taken as absolute sector alignment and can be zero"
			read local lv_alp
			[ -n "${lv_alp}" ] && lv_alp="--align-payload ${lv_alp}"
		else lv_header=; lv_alp=; fi
	fi
	cryptsetup ${lv_arg} ${lv_dev} -c${lv_cph:-aes-xts-plain:sha256} \
		-s${lv_ksz:-256} ${lv_ukf} ${lv_header} ${lv_alp} || \
		die "failed to create ${lv_dev} cyphertext volume."
}

dmopen() { 
	local lv_arg=luksFormat
	local lv_map=$(echo "${1}" | cut -d'-' -f1)
	local lv_dev=$(echo "${1#*-}" | cut -d'+' -f1); lv_dev=$(_blkid "${lv_dev}")
	local lv_header=$(echo "${1}" | cut -d'+' -s -f2)
	if [ -n "${lv_header}" ]; then
		if [ -n "$(echo "${lv_header}" | grep -E '(UUID|LABEL|sd[a-z][0-9])')" ]; then 
			lv_header=$(_blkid "${lv_header}")
			[ -b "${lv_header}" ] && lv_header="--header ${lv_header}" || \
			die "$lv_header block device doesn't exist."
		elif [ -e "/mnt/tok/${lv_header}" ]; then 
			lv_header="--header /mnt/tok/${lv_header}"
		else die "${lv_header} detached header doesn't exist."; fi
	fi
	cryptsetup isLuks "${lv_dev}"
	if [ ! "$?" ]; then
 		info "cre[ate] ${lv_dev} or dec[rypt] another LUKS PV? [cre|DEC]"
		read local lv_asw 
		if [ "${lv_asw:-dec}" == "dec" ]; then 
			while true; do
				info "Type in valid LUKS PV e.g. sda5|UUID=<uuid>|LABEL=<label>"
				read lv_dev; lv_dev=$(_blkid "${lv_dev}")
				cryptsetup isLuks "${lv_dev}" && break
			done
		elif [ "${lv_asw}" == "cre" ]; then dmcrypt; fi
	fi
	[ -b "${lv_dev}" ] || die "${lv_dev} block device doesn't exist."
	cryptsetup isLuks "${lv_dev}" &>/dev/null || die "No valid LUKS PV found."
	lv_arg=luksOpen
	if [ "${gv_cmode}" == "gpg" ]; then 
		mv /dev/tty /dev/tty.bak; cp -a /dev/console /dev/tty
		for i in 1 2 3; do
			gpg -qd "${gv_kfile}" | cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" \
				${lv_header} && break
			[ ${i} -eq 3 ] && warn "...there's still a fallback..."
		done
		rm /dev/tty && mv /dev/tty.bak /dev/tty
	elif [ "${gv_cmode}" == "ldk" ] || [ "${gv_cmode}" == "reg" ]; then 
		cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" -d "${gv_kfile}" \
		${lv_header} || warn "...there's still a fallback..."
	fi
	if [ ! -b "/dev/mapper/${lv_map}" ]; then
		cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" ${lv_header} || \
			die "Failed to decrypt ${lv_dev}."
	fi
}

_lvm() {
	[ "${uv_check_env}" ] || bchk "lvm" "--"
	if lvchange -ay ${1/-//}; then continue
	info "$? \n"
	elif [ -n "${2}" ]; then
		local lv_pv="${2}" IFS="${IFS}:"
		[ -e "/mnt/tok/${lv_pv}" ] && lv_pv="$(cat /mnt/tok/${lv_pv})"
		info $lv_pv
		for pv in ${lv_pv}; do dmopen "${pv}"; done
		vgchange -ay ${1%-*} &> /dev/null || dmclose "${lv_pv}" "${1}"
	else die "${1} require a valid crypted physical volume"; fi
	if [ -b "/dev/mapper/${1}" ]; then local lv_mapping=/dev/mapper/${1}
	elif [ -b "/dev/${1/-//}" ]; then local lv_mapping=/dev/${1/-//}
	else die "${1} VG/LV do not exist."; fi
	echo "$lv_mapping"
}

_raid() {
	local lv_dev=${1%%-*} lv_part=$(echo ${1} | cut -d'-' -f3)
	[ -n "$(echo ${lv_dev} | grep /dev)" ] || lv_dev=/dev/${lv_dev}
	[ -b ${lv_dev} ] && return
	if [ -n "$(echo ${1} | grep UUID)" ]; then
		if [ -n "${lv_part}" ]; then
			echo DEVICE $(ls /dev/sd*${lv_part}) >> /etc/mdadm.conf
		else echo 'DEVICE /dev/sd??*' >> /etc/mdadm.conf; fi
		echo ARRAY ${lv_dev} $(echo ${1} | cut -d'-' -f2) >> /etc/mdadm.conf
	fi
	mdadm --assemble --scan ${lv_dev} &>/dev/null || raidautorun
	[ -b ${lv_dev} ] || die "failed to activate ${lv_dev} RAID array."
}

squashd() {
	[ -n "$sqfsdir" ] || die "uv_sqfsdir wasn't set and sqfsdir is empty."
	[ -n "$sqfsd" ]   || die "uv_sqfsd wasn't set and sqfsd is empty."
	[ -d /newroot/"$sqfsdir" ] || die "sqfsdir=$sqfsdir dir doesn't exist."
	_modprobe sqfsd
	cd /newroot
	local IFS="${IFS}:"
	for dir in $sqfsd; do
		[ -e ."$sqfsdir/$dir".sfs ] || die "$dir.sfs image doesn't exist."
		mkdir -p ."$sqfsdir/$dir"/rw && mkdir -p ."$sqfsdir/$dir"/ro
		mount -t squashfs .${sqfsdir}/${dir}.sfs .${sqfsdir}/${dir}/ro \
			-o nodev,loop,ro &>/dev/null || die "Failed to mount squashed ${dir} image."
		mount -t aufs ${dir} ${dir} \
			-o nodev,udba=reval,br:.${sqfsdir}/${dir}/rw:.${sqfsdir}/${dir}/ro \
			&>/dev/null || die "Failed to mount squashed ${dir} aufs branch."
	done
}
rootfs() {
	local lv_kmod=${gv_kroot%%:*}
	local lv_kdev="$(echo "$gv_kroot"|cut -d':' -f2)"
	local lv_kfpt="$(echo "$gv_kroot"|cut -d':' -f3)"
	local lv_root=${gv_root%%:*}
	local lv_fsck="$(echo "$gv_root"|cut -d':' -f2)"
	local lv_rofs="$(echo "$gv_root"|cut -d':' -f3)"
:	local ${lv_lvm:=${gv_lvm%%,*}}
:	${lv_lvm:=${gv_lvm_root}}
:	local ${lv_raid:=${gv_raid%%,*}}
	local lv_fscf=${gv_root##*:}
	[ -n "${gbov_mtopt}" ] && local lv_mtopt="-o ${gv_mtopt}"
	[ -n "${lv_rofs}" ]  && lv_rofs="-t ${lv_rofs}"
	[ -n "${gv_root}" ] || die "iroot=* arg [PV|VG-LV][:fsck:<fs>] are missing."
	getkey "${lv_kmod}" "${lv_kdev}" "${lv_kfpt}" "root"
	ishrl 3d
	info "ROOT LV..."
	[ -n "${lv_raid}" ] && _raid "${lv_raid}"
	if [ -n "${lv_lvm}" ]; then 
		info lvm
		local lv_dev=$(_lvm "${lv_root}" "${lv_lvm}")
	elif [ -n "${gv_cmode}" ]; then info "...encrypted rootfs."
		dmopen "${uv_root_map:-root}-${gv_root}" 
		local lv_dev=/dev/mapper/${uv_root_map:-root}
	else local lv_dev=$(_blkid "${lv_root}"); fi
	ishrl 3f
	[ -n "${lv_fsck}" ] && fsck ${lv_rofs} ${lv_dev} 2>/dev/null 
	[ "$?" ] || { [ "${lv_fscf:-${uv_fscf:-y}}" = "y" ] && \
		die "Failed to fsck rootfs, exit-code: $?"; }
	ishrl 3m
	mount ${lv_mtopt} ${lv_rofs} ${lv_dev} /newroot &>/dev/null
	if [ ! "$?" ]; then
		if [ -n "${gv_cmode}" ]; then
			dmclose "${lv_lvm:-${uv_root_map:-root}}" "${lv_lvm:+${lv_root}}"
		fi
		die "Failed to mount rootfs."
	fi
	ishrl 3s
	[ -n "${sqfsd}" ] && squashd
	lv_lvm=; lv_mtopt=; gv_cmode=
}

swp() {
	local lv_hdev="$(echo "$2"|cut -d':' -s -f2)" 
	local lv_type=${2%%:*}
	local lv_sign="$(echo "$2"|cut -d':' -s -f3)"
	local lv_kmod=${3%%:*}
	local lv_kdev="$(echo "$3"|cut -d':' -s -f2)"
	local lv_kfpt=${3##*:}
	local lv_mapp=${1}
	[ -n "$lv_hdev" ] || die "${lv_mapp} dev|VG-LV is missing."
	[ -n "$lv_type" ] || die "${lv_mapp} type file|swap is missing."
	[ -n "$lv_sign" ] && lv_sign=:$lv_sign
	info "SWAP LV..."
	getkey "${lv_kmod}" "${lv_kdev}" "${lv_kfpt}" "root"
	[ -n "${lv_raid}" ] && _raid "${lv_raid}"
	if [ -n "${lv_lvm}" ]; then 
		gv_dev=${lv_type}:$(_lvm "${lv_hdev}" "${lv_lvm}")${lv_sign}
	elif [ -n "${gv_cmode}" ]; then info "...encrypted ${lv_mapp}."
		dmopen "${lv_mapp}-${lv_hdev}"
		gv_dev=${lv_type}:/dev/mapper/${lv_mapp}${lv_sign}
	else info "...unencrypted ${lv_mapp}."
		gv_dev=${lv_type}:$(_blkid "${lv_hdev}")${lv_sign}
	fi
	lv_lvm=; lv_raid=; gv_cmode=
}

resume() {
	[ "${gv_splash}" = "silent" ] || smsg "Resuming..."
	splashd_stop
	[ -n "$(echo "${gv_toi}"|cut -d':' -s -f2)" ] && {
:		local ${lv_raid:=$(echo "${gv_raid}" | cut -d',' -f3)}
:		local ${lv_lvm:=$(echo "${gv_lvm}" | cut -d',' -f3)}
:		${lv_lvm:=${gv_lvm_resume}}
		swp "resume"  "${gv_toi}" "${gv_kresume}"; }
	_modprobe tuxonice
	echo ${gv_dev} > /sys/power/tuxonice/resume
	local lv_img="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
	if [ ${lv_img} = 1 ]; then 
		warn "There is no recognizable signature at location pointed by iresume|iswap"
		warn "Do you want to proceed [NO|yes]? "
		read local lv_asw
		[ "${lv_asw:-no}" != "yes" ] && die "Resume aborted by user"
	elif [ ${lv_img} = 0 ]; then 
		die "No image exist at location pointed by iresume|iswap"; fi
	[ -n "${gv_splash_theme}" ] && ln -sf "/etc/splash/${gv_splash_theme}" \
		/etc/splash/tuxonice
	[ -n "$(which tuxoniceui_text)" ] && echo $(which tuxoniceui_text) > \
		/sys/power/tuxonice/user_interface/program
	[ -z "$(cat /sys/power/tuxonice/user_interface/program)" ] && \
		echo $(which tuxoniceui_fbsplash) >/sys/power/tuxonice/user_interface/program
	mount -n -o remount,ro / &>/dev/null
	info "RESUMING from hibernation S[4-5]."
	echo > /sys/power/tuxonice/do_resume
	mount -n -o remount,rw / &>/dev/null
	echo > /sys/power/tuxonice/image_exists
	_rmmod tuxonice
	die "Resume from hibernation failed, image destroied."
}

switch() {
	echo > /proc/sys/kernel/hotplug
	[ "${gv_splash}" == "silent" ] && silent && smsg "Switching / ..."
	info "SWITCHING root '/'..."
	splashd_stop
	sleep 1
	ishrl 4u
	umount -l /proc
	umount -l /sys
	umount -l /dev
	ishrl 4s
	exec switch_root /newroot ${uv_init:-/sbin/init} ${gv_inrl}
}

imsg() { [ -e /etc/msg ] && info "$(cat /etc/msg)"; }

main() {
	[ "${gv_splash}" == "verbose" ] && verbose
	if [ -n "${gv_kmap}" ]; then
		for dir in /usr/share/keymaps /etc /; do
			if [ -f "${dir}/${gv_kmap}" ]; then
				loadkmap < "${dir}/${gv_kmap}" && break \
					|| error "Failed to load ${gv_kmap} keymap"
			fi
		done
	fi
	if [ -n "${gv_font}" ]; then
		for dir in /usr/share/consolefonts /etc /; do
			if [ -f "${dir}/${gv_font}" ]; then
				loadfont < "${dir}/${gv_font}" && break \
					|| error "Failed to load ${gv_font} font"
			fi
		done
	fi
	imsg
	ishrl 1
	_modprobe gpg
	_modprobe remdev
	if [ -n "${gv_swap}" ]; then
:		local ${lv_raid:=$(echo "${gv_raid}" | cut -d',' -f2)}
:		local ${lv_lvm:=$(echo "${gv_lvm}" | cut -d',' -f2)}
:		${lv_lvm:=${gv_lvm_swap}}
		ishrl 2s
		swp "swap" "${gv_swap}" "${gv_kswap}"
	fi
	[ -n "${gv_toi}" ] && ishrl 2r && do_resume
	rootfs
	ishrl 4c
	local IFS="${IFS}:"
	for lk in ${gv_lkey}; do dmclose "${lk}"; done
	for ld in ${gv_ldev}; do losetup -d ${ld}; done
	_rmmod gpg
	umount -n -l /mnt/tok
	_rmmod remdev
	switch
}

_getopts() {
	local dir
	for arg in $(cat /proc/cmdline); do
    		case $arg in
			rescue)     gv_shrl=1;;
			isqfsd=*)   dir=${arg#*=}
				if [ "${dir%,*}" = "y" ]; then sqfsdir=${uv_sqfsdir:-/sqfsd}
				else sqfsdir=${dir%,*}; fi
				if [ "${dir#*,}" = "y" ]; then sqfsd=${uv_sqfsd:-usr:opt:bin:sbin}
				elif [ "$(echo ${dir#*,}|cut -d':' -f1)" = "a" ]; then
					sqfsd=${uv_sqfsd:-usr:opt:bin:sbin}:$(echo ${dir#*,}|cut -b3-)
				else 	sqfsd=$(echo ${dir#*,}|cut -b3-); fi;;
			iroot=*)    gv_root=${arg#*=};;
			iraid=*)    gv_raid=${arg#*=};;
			*init=*)    uv_init=${arg#*=};;
			ilvm=*)     gv_lvm=${arg#*=};;
			imod=*)     gv_mod=${arg#*=};;
			imtopt=*)   gv_mtopt=${arg#*=};;
			splash=*)   dir=${arg#*=}
				    gv_splash_theme=${dir#*:}
				    gv_splash=${dir%,*};;
			console=*)  gv_stty=${arg#*=};;
			iresume=*)  gv_toi=${arg#*=};;
			ikmap=*)    gv_kmap=$(echo ${arg#*=}|cut -d':' -f1)
				        gv_font=$(echo ${arg#*=}|cut -d':' -f2);;
			ishrl=*)    gv_shrl=$(echo ${arg#*=}|cut -d':' -f1)
				        gv_inrl=$(echo ${arg#*=}|cut -d':' -f2);;
			iswap=*)    gv_swap=${arg#*=};;
			ikroot=*)   gv_kroot=${arg#*=};;
			ikswap=*)   gv_kswap=${arg#*=};;
			ikresume=*) gv_kresume=${arg#*=};;
	   	 esac
	done
}

_init() {
	export PATH=/sbin:/bin:/usr/bin:/usr/sbin
#	dmesg -n 1
	umask 0077
	for dir in dev proc sys newroot mnt/tok; do mkdir -p /$dir; done
	mount -t proc proc /proc
#	busybox --install -s
	[ ${uv_check_env} ] || achk
	[ ${uv_check_env} ] || bchk "cryptsetup" "--"
	mount -t sysfs sysfs /sys
	_getopts
	[ -n "${gv_mod}" ] && { local IFS="${IFS},"
		for module in ${gv_mod}; do modprobe ${module} &>/dev/null; done
	}
	_modprobe boot
	mount -t tmpfs tmpfs /dev
	mdev -s
	echo /sbin/mdev > /proc/sys/kernel/hotplug
	[ -n "${gv_splash_theme}" ] && spalshd_init
	main
}
_init

# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
