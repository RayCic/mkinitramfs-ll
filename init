#!/bin/sh
# revision=0.3.5_p20110906
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.

# user defined variables
uv_init=/sbin/init 		# init to execute after switching to real root
uv_root_map=root 		# self descriptive
uv_check_env=0 			# test if busybox/applets and the other binaries exist 
uv_sqfsdir=/sqfsd 		# squashed source dir related variable
uv_sqfsd=usr:opt:bin:sbin:lib32	# squashed dirs variable
uv_fscf=y 			# whether to die after a failure to fsck rootfs

# default values(don't edit)
gv_active_splashutil=1
gv_splash_silent=verbose
gv_shell_checkpoint=0

# functions
info() 	{ echo -ne "\033[1;32m* \033[0m$@\n"; }
warn() 	{ echo -ne "\033[1;33m* \033[0m$@\n"; }
error() { echo -ne "\033[1;31m* \033[0m$@\n"; }

die() {
	umount -ln /mnt/tok &>/dev/null
	[ "${gv_splash_silent}" = "silent" ] || splash_verbose
	error "$@"
	info "Dropping you into a minimal shell..."
	exec /bin/sh
}

bin_exist() {
	[ -e "/bin/${1}" ] || [ -e "/sbin/${1}" ] || [ -e "/usr/bin/${1}" ] || \
		[ -e "/usr/sbin/${1}" ] || die "${2} ${1} not found."
}

check_busybox_applets() {
	if [ -e "/etc/applets" ]; then	
		for app in $(cat /etc/applets); do bin_exist ${app} "--"; done
	else die "Cannot check if BusyBox's /etc/applets exists"; fi
}

rmmod_group() {
	[ -f "/etc/modules/${1}" ] && for mod in $(cat /etc/modules/${1})
		do rmmod $(echo ${mod}|sed 's/-/_/g') &>/dev/null; done
}

modprobe_group() {
	[ -f "/etc/modules/${1}" ] && for mod in $(cat /etc/modules/${1})
		do modprobe ${mod} &>/dev/null; done
}

splash_command() { [ $gv_active_splashutil ] && echo "$@" >/lib/splash/cache/.splash; }

splash_verbose() { splash_command "set mode verbose"; }

splash_silent() { splash_command "set mode silent"; }

splash_message() { splash_command "set message $@"; splash_command "repaint"; }

splash_setup() {
	[ ${uv_check_env} ] || bin_exist "splash_util.static" "--"
	[ -n "$gv_splash_console" ] && exec < /dev/$gv_splash_console > /dev/$gv_splash_console &>/dev/null
	[ -e /lib/splash/cache ] || mkdir -p /lib/splash/cache
	[ -e /lib/splash/cache/.splash ] || mknod /lib/splash/cache/.splash p
	splash_util.static --daemon "--theme=$gv_splash_theme"
	gv_active_splashutil=0
}

splash_daemon_stop() { [ $gv_active_splashutil ] && gv_active_splashutil=1 splash_command "exit"; }

shell_checkpoint() {
	if [ ${gv_shell_checkpoint} = ${1} ]; then 
		splash_verbose
		info "Checkpoint ${1}"
	exec /bin/sh; fi
}

exec_losetup() {
	lv_ldk_dev="$(losetup -f)" || die "Create or append max_loop=<int> to the cmdline."
	losetup ${lv_ldk_dev} ${1} || die "Failed to setup losetup."
	echo ${lv_ldk_dev}
}

get_ldk_key() {
	local lv_ldk_dev=$(exec_losetup ${1})
	gv_ldk_dev="${gv_ldk_dev} ${lv_ldk_dev}"
	gv_ldk_key="${gv_ldk_key} ${2}"
	exec_cryptsetup "${lv_ldk_dev}" "${2}" && gv_kfile=/dev/mapper/${2} 
}

get_key() {
	local lv_mode=${1} 
	local lv_dev=${2} 
	gv_fpath=${3}
	gv_fname=${gv_fpath##*/}
	modprobe_group remdev
	[ -n "$(mount|grep /mnt/tok)" ] || { 
		[ -b "/dev/${lv_dev}" ] || { 
			info "Insert removable device and press Enter."
			read local lv_d
			info "Please wait a few seconds...."
			sleep 3
			[ -b "/dev/${lv_dev}" ] || {
				info "${lv_dev} does not exist, input a valid dev name e.g. sdb1"
				read lv_dev
				info "Please wait a few seconds...."
				sleep 3; }
		[ -b "/dev/${lv_dev}" ] || die "${lv_dev} remdev does not exist."; }
	mount -n -r "/dev/${lv_dev}" /mnt/tok &>/dev/null || die "Failed to mount ${lv_dev} remdev."
		info "Removalble device mounted."; }
	[ -f "/mnt/tok/${gv_fpath}" ] || die "${gv_fpath} keyfile does not exist in ${lv_dev} remdev."
	case ${lv_mode} in
		gpg)	[ ${uv_check_env} ] || bin_exist "gpg" "--"
			gv_kfile="/mnt/tok/${gv_fpath}"; gv_kgpg=0;;
		reg) 	gv_kfile="/mnt/tok/${gv_fpath}";;
		ldk)	[ -e "/dev/mapper/${gv_fname}" ] && gv_kfile=/dev/mapper/${gv_fname} || \
				get_ldk_key "/mnt/tok/${gv_fpath}" "${gv_fname}"; gv_kldk=0;;
		*) 	die "${lv_mode}:mode is not valid.";; 
	esac
}

check_key() {
	if [ "${1}" = "ldk" ] || [ "${1}" = "gpg" ] || [ "${1}" = "reg" ]; then
	[ -n "${2}" ] || die "ik${4}=${1}:${2}:${3} device field empty."
	[ -n "${3}" ] || die "ik${4}=${1}:${2}:${3} filepath field empty."
	get_key "${1}" "${2}" "${3}"; fi
}

close_cryptsetup() { cryptsetup luksClose ${1} || cryptsetup remove ${1} || die "${2}"; }

exec_cryptsetup() { 
	local lv_arg=luksFormat 
	local lv_dev=${1}
	local lv_map=${2}
	[ "${lv_dev%/*}" = "/dev" ] || lv_dev=/dev/${lv_dev}
	cryptsetup isLuks "${lv_dev}" || {
 	info "Do you want to cre[ate] ${lv_dev} or dec[rypt] another LUKS PV? [cre|DEC]"
	read local lv_asw 
	if [ "${lv_asw:-dec}" = "dec" ]; then 
		for i in 1 2 3; do
			info "Type another (valid LUKS) PV e.g. sda5"; read lv_dev 
			lv_dev=/dev/${lv_dev}; cryptsetup isLuks "${lv_dev}" && break; 	done
	elif [ "${lv_asw}" = "cre" ]; then 
		info "Type a valid LUKS cipher:hash, default is 'aes-xts-plain:sha256'"
		info "you can take something safer like 'aes-cbc-essiv:sha256'"
		read local lv_cph
		info "Type a valide key-size [256|512], default is 256 bits:"
		read local lv_ksz
		if [ -e "${gv_kfile}" ]; then 
			info "Do you want to use the existing ${gv_kfile} key-file? [NO|yes]"
			read local lv_ukf
			[ "${lv_ukf:-no}" = "yes" ] && lv_ukf="-d ${lv_ukf}"; fi
		for i in 1 2 3; do
			cryptsetup ${lv_arg} ${lv_dev} -c${lv_cph:-aes-xts-plain:sha256} \
				-s${lv_ksz:-256} ${lv_ukf} && break; done; fi; }
	cryptsetup isLuks "${lv_dev}" &>/dev/null || die "No valid LUKS PV found."
	lv_arg=luksOpen
	if [ ${gv_kgpg} ]; then mv /dev/tty /dev/tty.bak && cp -a /dev/console /dev/tty
		for i in 1 2 3; do
			gpg -qd "${gv_kfile}"|cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" \
				&& break
			[ ${i} -eq 3 ] && warn "...there's still a fallback..."; done
		rm /dev/tty && mv /dev/tty.bak /dev/tty; gv_kgpg=
	elif [ ${gv_kldk} ]; then 
		cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" -d "${gv_kfile}"
		[ "$?" ] || warn "...there's still a fallback..."; gv_kldk=; fi
	if [ ! -b "/dev/mapper/${lv_map}" ]; then cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}"
		[ "$?" ] || die "Failed to decrypt ${lv_dev}."; fi
}

exec_lvm() {
	[ ${uv_check_env} ] || bin_exist "lvm" "--"
	local lv_vg=${2/-//}
	local lv_pv=$(echo "${1}"|tr ':' ' ')
	lvchange -ay ${lv_vg} &>/dev/null || for pv in ${lv_pv}
		do exec_cryptsetup "${pv#*-}" "${pv%-*}"; done
	lvchange -ay ${lv_vg} &>/dev/null || { 
		vgchange -an ${lv_vg%/*} &>/dev/null
		warn "Disabling ${lv_vg} VG/LV..."
		for pv in ${lv_pv}; do close_cryptsetup "${pv%-*}" "${pv}"; done
		[ -n "${gv_fname}" ] && close_cryptsetup "${gv_fname}" "${gv_fname}"
		die "Encrypted PV [and key-file] closed."; }
	if   [ -b "/dev/mapper/${2}" ]; then local lv_dev=/dev/mapper/${2}
	elif [ -b "/dev/${lv_vg}" ]; 	then local lv_dev=/dev/${lv_vg}
	else die "${lv_vg} VG/LV do not exist."; fi
	echo ${lv_dev}
}

do_sqfsd_work() {
	[ -n "$sqfsdir" ] || die "uv_sqfsdir wasn't set and sqfsdir is empty."
	[ -n "$sqfsd" ]   || die "uv_sqfsd wasn't set and sqfsd is empty."
	[ -d /newroot/"$sqfsdir" ] || die "sqfsdir=$sqfsdir dir doesn't exist."
	sqfsd="$(echo "$sqfsd"|tr ':' ' ')"
	modprobe_group sqfsd
	cd /newroot
	for dir in $sqfsd; do
		[ -e ."$sqfsdir/$dir".sfs ] || die "$dir.sfs image doesn't exist."
		mkdir -p ."$sqfsdir/$dir"/rw && mkdir -p ."$sqfsdir/$dir"/ro
		mount -t squashfs .$sqfsdir/$dir.sfs .$sqfsdir/$dir/ro -o nodev,loop,ro &>/dev/null
		[ "$?" ] || die "Failed to mount squashed $dir image."
	mount -t aufs $dir $dir -o nodev,udba=reval,br:.$sqfsdir/$dir/rw:.$sqfsdir/$dir/ro &>/dev/null
		[ "$?" ] || die "Failed to mount squashed $dir aufs branch."
	done
}
do_root_work() {
	local lv_kmod=${gv_kroot%%:*}
	local lv_kdev="$(echo "$gv_kroot"|cut -d':' -f2)"
	local lv_kfpt="$(echo "$gv_kroot"|cut -d':' -f3)"
	local lv_root=${gv_root%%:*}
	local lv_fsck="$(echo "$gv_root"|cut -d':' -f2)"
	local lv_rofs="$(echo "$gv_root"|cut -d':' -f3)"
	local lv_fscf=${gv_root##*:}
:	local ${lv_mtopt:=$gv_mtopt} 
:	local ${lv_lvm:=${gv_lvm%%,*}}
	[ -n "${lv_mtopt}" ] && lv_mtopt="-o ${lv_mtopt}"
	[ -n "${lv_rofs}" ]  && lv_rofs="-t ${lv_rofs}"
	[ -n "${gv_root}" ] || die "iroot=* arg [PV|VG-LV][:fsck:<fs>] are missing."
	[ "${lv_kmod}" != "none" ]  && local lv_crypt=0 && \
		check_key "${lv_kmod}" "${lv_kdev}" "${lv_kfpt}" "root"
	shell_checkpoint 4
	info "ROOT LV..."
	if [ "${lv_crypt}" ]; then info "...encrypted rootfs."
		if [ -n "${lv_lvm}" ]; then 
			local lv_rdev=$(exec_lvm "${lv_lvm}" "${lv_root}")
		else	exec_cryptsetup "${gv_root}" "${uv_root_map:-root}" 
			local lv_rdev=/dev/mapper/${uv_root_map:-root}; fi
	else 	info "...unencrypted rootfs." && local lv_rdev=/dev/${gv_root}; fi
	shell_checkpoint 5
	[ -n "${lv_fsck}" ] && fsck ${lv_rofs} ${lv_rdev} 2>/dev/null 
	[ "$?" ] || {
		[ "${lv_fscf:-${uv_fscf:-y}}" = "y" ] && die "Failed to fsck rootfs, exit-code: $?"; }
	mount ${lv_mtopt} ${lv_rofs} ${lv_rdev} /newroot &>/dev/null
	[ "$?" ] || {
		if [ "${lv_crypt}" ]; then
			if [ -n "${lv_lvm}" ]; then
				warn "Disabling ${lv_root} VG-LV..."
				vgchange -an ${lv_root%-*} &>/dev/null
				for lv_pv in $(echo "${lv_lvm}"|tr ':' ' '); do
					close_cryptsetup "${lv_pv%-*}" "${lv_pv}"; done
			else 	close_cryptsetup "${uv_root_map:-root}" "${uv_root_map:-root}"; fi
			[ -n "${gv_fname}" ] && close_cryptsetup "${gv_fname}" "${gv_fname}"; fi
		die "Failed to mount rootfs."; }
	[ -n "${sqfsd}" ] && do_sqfsd_work
	lv_lvm=; lv_mtopt= 
	shell_checkpoint 6
}

do_swap_work() {
       	local lv_hdev="$(echo "$2"|cut -d':' -s -f2)" 
	local lv_type=${2%%:*}
	local lv_sign="$(echo "$2"|cut -d':' -s -f3)"
	local lv_kmod=${3%%:*}
	local lv_kdev="$(echo "$3"|cut -d':' -s -f2)"
	local lv_kfpt=${3##*:}
	local lv_mapp=${1}
	[ -n "$lv_hdev" ] || die "${lv_mapp} dev|VG-LV is missing."
	[ -n "$lv_type" ] || die "${lv_mapp} type file|swap is missing."
	[ -n "$lv_sign" ] && lv_sign=:$lv_sign
	shell_checkpoint 2
	info "SWAP LV..."
	check_key "${lv_kmod}" "${lv_kdev}" "${lv_kfpt}" "${lv_mapp}"
	if [ -n "${lv_lvm}" ]; then
		gv_dev=${lv_type}:$(exec_lvm "${lv_lvm}" "${lv_hdev}")${lv_sign}
	else 	exec_cryptsetup "${lv_hdev}" "${lv_mapp}" 
		gv_dev=${lv_type}:/dev/mapper/${lv_mapp}${lv_sign}; fi
	lv_lvm=
	shell_checkpoint 3
}

do_resume() {
	[ "${gv_splash_silent}" = "silent" ] || splash_message "Resuming..."
	splash_daemon_stop
	[ -n "$(echo "${gv_toi}"|cut -d':' -s -f2)" ] && {
:       	local ${lv_lvm:=$(echo "${gv_lvm}"|cut -d',' -s -f3)}
		do_swap_work "resume"  "${gv_toi}" "${gv_kresume}"; }
	modprobe_group tuxonice
	echo ${gv_dev} > /sys/power/tuxonice/resume
	local lv_img="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
	if [ ${lv_img} = 1 ]; then 
		warn "There is no recognizable signature at location pointed by iresume|iswap"
		warn "Do you want to proceed [NO|yes]? "
		read local lv_asw
		[ "${lv_asw:-no}" != "yes" ] && die "Resume aborted by user"
	elif [ ${lv_img} = 0 ]; then 
		die "No image exist at location pointed by iresume|iswap"; fi
	[ -n "${gv_splash_theme}" ] && ln -sf "/etc/splash/${gv_splash_theme}" /etc/splash/tuxonice
	[ -n "$(which tuxoniceui_text)" ] && echo $(which tuxoniceui_text) > \
		/sys/power/tuxonice/user_interface/program
	[ -z "$(cat /sys/power/tuxonice/user_interface/program)" ] && \
		echo $(which tuxoniceui_fbsplash) >/sys/power/tuxonice/user_interface/program
	mount -n -o remount,ro / &>/dev/null
	info "RESUMING from hibernation S[4-5]."
	echo > /sys/power/tuxonice/do_resume
	mount -n -o remount,rw / &>/dev/null
	echo > /sys/power/tuxonice/image_exists
	rmmod_group tuxonice
	die "Resume from hibernation failed, image destroied."
}

do_switch() {
	echo > /proc/sys/kernel/hotplug
	[ "${gv_splash_silent}" = "silent" ] && splash_silent && splash_message "Switching / ..."
	info "SWITCHING root '/'..."
	splash_daemon_stop
	sleep 1
	/bin/umount -l /proc
	/bin/umount -l /sys
	/bin/umount -l /dev
	shell_checkpoint 7
	exec switch_root /newroot ${uv_init:-/sbin/init}
}

print_msg() {
#       clear
	[ -e /etc/msg ] && info "$(cat /etc/msg)"
}

do_work() {
	[ "${gv_splash_silent}" = "verbose" ] && splash_verbose
	[ -n "${gv_kmap}" ] && [ -e "/etc/${gv_kmap}" ] && { 
		loadkmap < "/etc/${gv_kmap}" || die "Failed to load ${gv_kmap} key-map."; }
	[ -n "$gv_font" ] && [ -e "/etc/${gv_font}" ] && { 
		loadfont < "/etc/${gv_font}" || die "Failed to load ${gv_font} font."; }
	print_msg
	shell_checkpoint 1
	modprobe_group gpg
	modprobe_group remdev
	if [ -n "${gv_swap}" ]; then
:       	local ${lv_lvm:=$(echo "${gv_lvm}"|cut -d',' -s -f2)}
		do_swap_work "swap" "${gv_swap}" "${gv_kswap}"; fi
	[ -n "${gv_toi}" ] && do_resume
	do_root_work
	for lk in ${gv_ldk_key}; do close_cryptsetup ${lk} ${lk}; done
	for ld in ${gv_ldk_dev}; do losetup -d ${ld}; done
	rmmod_group gpg
	umount -n -l /mnt/tok
	rmmod_group remdev
	do_switch
}

parse_cmdline_args() {
	local dir
	for arg in $(cat /proc/cmdline); do
    		case $arg in
			rescue)     gv_shell_checkpoint=1;;
			isqfsd=*)   dir=${arg#*=}
				if [ "${dir%,*}" = "y" ]; then sqfsdir=${uv_sqfsdir:-/sqfsd}
				else sqfsdir=${dir%,*}; fi
				if [ "${dir#*,}" = "y" ]; then sqfsd=${uv_sqfsd:-usr:opt:bin:sbin}
				elif [ "$(echo ${dir#*,}|cut -d':' -f1)" = "a" ]; then
					sqfsd=${uv_sqfsd:-usr:opt:bin:sbin}:$(echo ${dir#*,}|cut -b3-)
				else 	sqfsd=$(echo ${dir#*,}|cut -b3-); fi;;
			iroot=*)    gv_root=${arg#*=};;
			ilvm=*)     gv_lvm=${arg#*=};;
			imtopt=*)   gv_mtopt=${arg#*=};;
			splash=*)   dir=${arg#*=}
				    gv_splash_theme=${dir#*:}
				    gv_splash_silent=${dir%,*};;
			console=*)  gv_splash_console=${arg#*=};;
			iresume=*)  gv_toi=${arg#*=};;
			ikmap=*)    gv_kmap=$(echo ${arg#*=}|cut -d':' -f1)
				    gv_font=$(echo ${arg#*=}|cut -d':' -f2);;
			ichkpt=*)   gv_shell_checkpoint=${arg#*=};;
			iswap=*)    gv_swap=${arg#*=};;
			ikroot=*)   gv_kroot=${arg#*=};;
			ikswap=*)   gv_kswap=${arg#*=};;
			ikresume=*) gv_kresume=${arg#*=};;
	   	 esac
	done
}

main() {
	export PATH=/sbin:/bin:/usr/bin:/usr/sbin
#	dmesg -n 1
	umask 0077
	for dir in proc sys newroot mnt/tok; do mkdir -p /$dir; done
	/bin/mount -t proc proc /proc
#	/bin/busybox --install -s
	[ ${uv_check_env} ] || check_busybox_applets
	[ ${uv_check_env} ] || bin_exist "cryptsetup" "--"
	/bin/mount -t sysfs sysfs /sys
	parse_cmdline_args
	modprobe_group boot
	/bin/mount -t tmpfs tmpfs /dev
	/sbin/mdev -s
	echo /sbin/mdev > /proc/sys/kernel/hotplug
	[ -n "$gv_splash_theme" ] && splash_setup
	# fix /dev/device-mapper should be /dev/mapper/control on amd64?
	[ -e "/dev/mapper/control" ] || { # see /sys/class/misc/device-mapper/dev 
		mkdir -p /dev/mapper && mv /dev/device-mapper /dev/mapper/control
		echo "device-mapper mapper/control issue fixed.." >> /.initlog;	}
	do_work
}
main
