#!/bin/sh
# $Header: mkinitramfs-ll/init,v 0.12.0 2013/04/12 04:37:26 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.

# @VARIABLE: eck
# @DEFAUT_SET
# @DESCRIPTION: Environment ChecK, whether or not to check binaries
# and busybox applets

# @VAIABLE: init
# @DEFAULT_SET
# @DESCRIPTION: real init

# @VARIABLE: initlib
# @DEFAULT_SET
# @DESCRIPTION: path to default mkinitramfs-ll library dir

# @VARIABLE: map
# @DEAULT_SET
# @DESCRIPTION: root dm-crypt LUKS mapping

# @VARIABLE: sh
# @DEFAULT_SET
# @DESCRIPTION: shell for scripts and user scripts execution and rescue shell

# @VARIABLE: logfile
# @DEFAULT_SET
# @DESCRIPTION: log file to log execution commands for debugging

# @VARIABLE: spld
# @DEFAULT_SET
# @DESCRIPTION: splash deamon running variable

export init=/sbin/init initlib=/lib/mkinitramfs-ll moddir=/etc/mkinitramfs-ll.d
export eck=true logfile=$0.log map=root sh=/bin/sh spld=false
export HOME=/root PATH=/sbin:/bin:/usr/bin:/usr/sbin 

source $initlib/functions.sh || $sh -a

# @FUNCTION: dolevel
# @INTERNAL
# @DESCRIPTION: make run level and drop to rescue shell if $level = $shlevel
dolevel() {
	local _msg="Switching to init shell run level: $1"
	echo -ne ">>> $_msg\n"
	msg ">>> $_msg"
	export level=$1

	local _file="$(ls $moddir/*.$1 2>/dev/null)"
	if [ -n "$_file" ]; then
		for _f in $_file; do
			info "exec: $sh -aex $_f..."
			debug -d $sh -aex $_f
			if [ -f /run/env ]; then
				while read line; do
					export $line
				done </run/env
				rm -f /run/env; fi
			[ -f /run/${_s##*/}.pid ] && rm -f /run/${_s##*/}.pid && debug die
			exec 0<$console 1>$console 2>&1	
		done
	fi

	[ "$shlevel" = "$1" ] && debug die
	return 0
}

# @FUNCTION: spld
# @INTERNAL
# @DESCRIPTION: run splash deamon
spld() {
	$eck && for bin in fbcondecor_helper splash_util; do 
		debug -d bck $bin
	done
	local IFS="${IFS}," _opt _opts cachedir event mode msg theme util
	event="$(grep -Hsi keyboard /sys/class/input/input*/name | \
		sed -e 's#.*input\([0-9]*\)/name.*#event\1#')"
:	${cachedir:=/run/splash/cache}
	splu=$(which splash_util)
:	${BOOT_MSG:="Booting the system (\$progress%)... Press F2 for verbose mode."}
:	${SPLASH_FIFO=$cachedir/.splash}
	export BOOT_MSG cachedir SPLASH_FIFO
	
	for _opt in $splash; do
		case ${_opt%:*} in
			fad*) _opts="set effects $_opt"
				;;
			silent|verbose) mode=$_opt
				;;
			tty) console=/dev/${_opt/:/}
				;;
			theme) theme=${_opt#*:}
				;;
		esac
	done

	[ -d "$cachedir" ] || mkdir -p $cachedir
	debug mkfifo $SPLASH_FIFO
	debug $splu -d -ms -t$theme && spld=true
	[ -n "$_opts" ] && debug cmd $_opts
	debug cmd "set event dev /dev/input/$event"
	debug cmd "set autoverbose 0"
	debug ${mode:-verbose}
}

# @FUNCTION: dorootfs
# @INTERNAL
# @DESCRIPTION: mount rootfs on /newroot before switching to real init
dorootfs() {
	debug -d"iroot=<PV|VG-LV>[:<c>:<fs>] argument is missing" test -n "$iroot"
	local _dev=${iroot%%:*}
	local _fsck="$(echo "$iroot" | cut -d: -s -f2)"
	local _fs="$(echo "$iroot" | cut -d: -s -f3)"
:	local ${_lvm:=$(echo "$ilvm" | cut -d',' -f1)}
:	local ${_raid:=$(echo "$iraid" | cut -d',' -f1)}

	debug -d stk "${ikroot:-pwd}" "root"

	dolevel 3d
	[ -n "$_raid" ] && mdopen "$_raid" "dev"

	if [ -z "$rootfs" ]; then
		if [ -n "$_lvm" ]; then
			debug -d lvopen "$_dev" "$_lvm" "dev"
		elif [ -n "$kmode" ]; then
			[ "$kmode" != "none" ] && debug -d dmopen "${map:-root}-$iroot" "dev"
			[ "$kmode" == "none" ] && debug -d blk "$_dev" "dev"
		fi
	
		dolevel 3f
		if [ -n "$_fsck" ]; then 
			case $_fsck in
				n*|N*) _fsck=-e
					;;
				c*|y*|Y*) _fsck=-d
					;;
				*) _fsck
					;;
			esac
			debug $_fsck fsck ${_fs:+-t$_fs} $dev 
		fi
	
		dolevel 3m
		debug mount ${imopt:+-o$imopt} ${_fs:+-t$_fs} $dev /newroot ||
		{
			[ -n "$kmode" ] &&
				debug -d dmclose "${_lvm:-${map:-root}}" "${_lvm:+${dev##*/}}" ||
				die "failed to mount rootfs"
		}
	fi
	
	dolevel 3s
	[ -n "$sqfsd" ] && debug -d squashd
	unset imopt iroot ikroot kmode sqfsdir sqfsd
}

# @FUNCTION: doswap
# @INTERNAL
# @DESCRIPTION: manage swap related stuff, decrypt...
doswap() {
	debug -d"i$1=<type>:<PV|VG-LV>[:<sign>] argument is missing" test -n "$2"
	local _swp="$3" _type="${1%%:*}"
	local _dev="$(echo "$1" | cut -d: -s -f2)" 
	local _sign="$(echo "$1" | cut -d: -s -f3)"

	debug -d stk "${2:-pwd}" "$_swp"
	
	[ -n "$_raid" ] && debug -d mdopen "$_raid" "dev"
	if [ "$swap" != "$3" ]; then
		if [ -n "$_lvm" ]; then
			debug -d lvopen "$_dev" "$_lvm" "dev"
		elif [ "$kmode" != "none" ]; then
			debug -d dmopen "$_swp-$dev" "dev"
		elif [ "$kmode" == "none" ]; then
			debug -d blk "$_dev" "dev"
		fi
	fi

	[ -n "$4" ] && eval ${4:-swp}=$_type:$dev${_sign+:$_sign}
	unset i$1 ik$1 kmode
}

# @FUNCTION: doresume
# @INTERNAL
# @DESCRIPTON: resume after a hibernation, TuxOnIce may work, the kernal implementation
# should be fixed/finished before use [WARN].
doresume() {
	local _asw _dev _img _msg _toi _spd
	_msg="Resuming from hibernation..."
	info "$_msg"
	msg "$_msg"

	if [ -n "$(echo "$iresume" | cut -d: -s -f2)" ]; then
:		local ${_raid:=$(echo "$iraid" | cut -d',' -f3 -s)}
:		local ${_lvm:=$(echo "$ilvm" | cut -d',' -f3 -s)}
		debug -d doswap "$iresume" "$ikresume" "resume" "_dev"
	fi
	
	debug -d mount -n -o remount,ro /newroot
	
	if [ -d /sys/power/tuxonice ]; then
		_toi="$(which tuxoniceui_text)"
:		${_toi:=$(which tuxoniceui_fbsplash)}
		debug _modprobe tuxonice
		echo $_dev >/sys/power/tuxonice/resume
		_img="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "toi: no recognizable signature at the pointed location"
			error "toi: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "toi: resume aborted"
		else
			die "toi: no image found at the pointed location"
		fi
		if [ -n "$theme" ]; then
			debug ln -sf "/etc/splash/$theme" /etc/splash/tuxonice
		fi
		_stop
		echo $_toi >/sys/power/tuxonice/user_interface/program
		echo >/sys/power/tuxonice/do_resume
		echo >/sys/power/tuxonice/image_exists
		debug _rmmod tuxonice
	elif [ -f /sys/power/resume ]; then
		_spd="$(which suspendui_text)"
:		${_spd:=$(which suspendui_fbsplash)}
		debug _modprobe swsusp
		echo $_dev >/sys/power/disk/resume
		_img="$(cat /sys/power/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "suspend: no recognizable signature at the pointed location"
			error "suspend: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "suspend: resume aborted"
		else
			die "suspend: no image found at the pointed location"
		fi
		_stop
		echo disk >/sys/power/state
		debug _rmmod swsusp
	else
		error "no suspend/hibernation support found"
	fi
	
	debug -d mount -n -o remount,rw /newroot
	die "failed to resume from hibernation"
}

# @FUNCTION: doswitch
# @INTERNAL
# @DESCRIPTION: switch to new root
doswitch() {
	echo >/proc/sys/kernel/hotplug
	local _msg="Switching / ..."
	info "$_msg"; msg "$_msg"
	debug _stop
	sleep 1
	dolevel 4u
	debug -d umount -l /proc
	debug -d umount -l /sys
	debug -d umount -l /dev/pts
	debug -d umount -l /dev
	debug -d umount -l /run
	dolevel 4s
	debug -d exec switch_root /newroot ${init:-/sbin/init} $runlevel
}

# FUNCTION: main
# @INTERNAL
# @DESCRIPTION: main loop of mkinitrafs-ll
main() {
	debug _init

	local _font=$(echo "$ikmap" | cut -d: -s -f2)
	local _kmap=$(echo "$ikmap" | cut -d: -f1)
	
	if [ -n "$_kmap" ]; then
		for _dir in /usr/share/keymaps /etc /; do
			if [ -f "$_dir/$_kmap" ]; then
				debug -d loadkmap <"$_dir/$_kmap" && break
			fi
		done
	fi

	if [ -n "$_font" ]; then
		for _dir in /usr/share/consolefonts /etc /; do
			if [ -f "$_dir/$_font" ]; then
				debug -d loadfont <"$_dir/$_font" && break
			fi
		done
	fi
	
	[ -f /etc/issue.logo ] && cat /etc/issue.logo
	debug test -f /etc/msg && clear &&
	while read _line; do
		info "$_line"
		msg "$_line"
	done </etc/msg
	
	debug _modprobe gpg
	debug _modprobe remdev
	dolevel 1
	
	if [ -n "$iswap" ]; then
:		local ${_raid:=$(echo "$iraid" | cut -d',' -f2 -s)}
:		local ${_lvm:=$(echo "$ilvm" | cut -d',' -f2 -s)}
		dolevel 2s
		doswap "$iswap" "$ikswap" "swap"
	fi
	
	[ -n "$iresume" ] && dolevel 2r && debug doresume
	
	debug dorootfs
	
	dolevel 4c
	local IFS="${IFS}:"
	
	for _k in $ldk; do
		debug dmclose "$_k"
	done
	
	for _d in $ldv; do
		debug losetup -d $_d
	done
	
	debug _rmmod gpg
	debug -d umount -f -l /mnt/tok
	debug _rmmod remdev
	
	[ -n "$imount" ] && dolevel 4m && debug domount
	
	debug doswitch
}

# @FUNCTION: _getopts
# @INTERNAL
# @DESCRIPTION: get kernel commands line option
_getopts() {
	for arg in $(cat /proc/cmdline); do
    	case $arg in
			rescue*) shlevel=1
				;;
			ro|rw) [ -n "$imtop" ] && imtopt="$arg,$imtopt" || imtopt="$arg"
				;;
			single) runlevel=2
				;;
			isqfsd=*) export "$arg"
				[ "${isqfsd%,*}" = "y" ] && sqfsdir="${sqfsdir:-/sqfsd}" ||
					sqfsdir=${isqfsd%,*}
				
				if [ "${isqfsd#*,}" = "y" ]; then sqfsd="${sqfsd:-usr:opt:bin:sbin}"
				elif [ "$(echo ${isqfsd#*,}|cut -d: -f1)" = "a" ]; then
					sqfsd="${sqfsd:-usr:opt:bin:sbin}:$(echo ${isqfsd#*,} | cut -c3-)"
				else
					sqfsd="$(echo ${isqfsd#*,} | cut -c3-)"
				fi
				;;
			i[dklmn]*) export "$arg"
				;;
			ishrl=*) shlevel=$(echo ${arg#*=}|cut -d: -f1)
				runlevel=$(echo ${arg#*=}|cut -d: -s -f2)
				;;
			dmesg|*root*|*resume*|*swap*|splash*|console*) export "$arg"
				;;
	   	 esac
	done
}

# @FUNCTION: _init
# @INTERNAL
# @DESCRIPTION: pre-init or initialization function before calling the main loop
_init() {

	debug -d mkdir -p dev/pts proc run sys newroot mnt/tok
	debug -d mount -t proc proc /proc
	
	debug _getopts
	
	[ -n "$idebug" ] && set -x

	debug -d mount -t sysfs sysfs /sys
	debug -d mount -t tmpfs -o mode=755 tmpfs /run
	debug -d mkdir -p /run/log && export logdir=/run/log
	
	debug umask 0077

	debug mv -f $logfile $logdir
	
	$eck && debug ack
	
	[ -n "$dmesg" ] && debug dmesg -n $dmesg
	
	debug _modprobe boot
	
	if grep devtmpfs /proc/filesystems 1>/dev/null 2>&1; then
		debug -d mount -t devtmpfs devtmpfs /dev
	else
		debug -d mount -t tmpfs tmpfs /dev
	fi
	
	debug mkdir /dev/pts
	debug mount -t devpts -o gid=5,mode=0620 devpts /dev/pts
	
	echo >/dev/mdev.seq
	debug -d mdev -s
	echo /sbin/mdev >/proc/sys/kernel/hotplug
	
	if [ -n "$imod" ]; then local IFS="${IFS},"
		for _m in $imod; do 
			debug modprobe $_m 1>/dev/null 2>&1
		done
	fi
	
	[ -h /dev/fd     ] || debug ln -fs /proc/self/fd   /dev/fd
	[ -n /dev/stderr ] || debug ln -fs /proc/self/fd/2 /dev/stderr
	[ -n /dev/stdin  ] || debug ln -fs /proc/self/fd/0 /dev/stdin
	[ -n /dev/stdout ] || debug ln -fs /proc/self/fd/1 /dev/stdout

:	${console:=/dev/tty1}
	[ -n "$(echo $console | grep /dev)" ] || console="/dev/$tty"
	exec 0<$console 1>$console 2>&1
	export console

	[ -n "$splash" ] && debug spld
}

main

# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
