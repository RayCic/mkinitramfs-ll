#!/bin/sh
#
# $Header: mkinitramfs-ll/init                           Exp $
# $Author: (c) 2011-2015 -tclover <tokiclover@gmail.com> Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 0.20.0 2015/05/20 12:33:03                   Exp $
#
# WARNING: USE AT YOUR OWN RISK! EVERYTHING IS GIVEN “AS IS”, SEE COPYING FILE
#

# Enable ChecKing binaries & busybox applets
:   ${ENV_CHK=true}
# Set real (path to) init
:   ${init=/sbin/init}
# Set configuration directory path
:   ${CONFDIR=/etc/mkinitramfs-ll}
# Set library directory path
:   ${LIBDIR=/lib/mkinitramfs-ll}
# Set SHell to use
:   ${sh=/bin/sh}
# Set log file to use (for debugging)
:   ${LOGFILE=$0.log}
# Set mount point to use for removable token or device
:   ${MNTDIR=/mnt/tok}
# Set New root directory to switch root
:   ${NEWROOT=/newroot}
# Set SPLash Daemon running state
:   ${SPLASHD=false}
:   ${NULL=/dev/null}

export CONFDIR LIBDIR LOGFILE MNTDIR NEWROOT SPLASHD init sh
export HOME=/root PATH=/sbin:/bin:/usr/bin:/usr/sbin
export PS1='-(rsh:$(tty | cut -c6-):$PWD)-# ' PS2='-# '

# @FUNCTION: Handle fatal error
# @ARG: <msg>
die() {
	local _ret=$?
	[ -n "$@" ] && msg -e "[$_ret]: $@"
	msg -c RED "Dropping to a Rescue Shell"
	$SPLASHD && splashd_stop
	debug rsh || debug $sh -aim
}

source $LIBDIR/functions || $sh -aim
eval_colors
name=init

# @FUNCTION: Shell Run Level helper
# @ARG: <level>
level() {
	msg -c GRN "Switching to init shell run level $CLR_BLU$1$CLR_RST"
	export LEVEL=$1
	for _f in $(ls $LIBDIR/${1}-* 2>$NULL); do
		dohook "$_f"
	done
	case "$LEVEL" in
		("$RSH") debug die;;
	esac
	return 0
}

# @FUNCTION: Splash daemon helper
splashd() {
	$ENV_CHK && debug -d bck fbcondecor_helper splash_util
	local IFS="${IFS}," _opt _opts cachedir event mode theme
	
	event="$(grep -Hsi keyboard /sys/class/input/input*/name | \
		sed -e 's#.*input\([0-9]*\)/name.*#event\1#')"
:	${cachedir:=/run/splash/cache}
:	${BOOT_MSG:="Booting the system (\$progress%)... Press F2 for verbose mode."}
:	${SPLASH_FIFO=$cachedir/.splash}
	export BOOT_MSG SPLASH_FIFO
	
	for _opt in $splash; do
		case "${_opt%:*}" in
			(fad*) _opts="set effects $_opt"      ;;
			(silent|verbose) mode="$_opt"         ;;
			(tty) export CONSOLE=/dev/"${_opt/:/}";;
			(theme) theme="${_opt#*:}"            ;;
		esac
	done

	[ -d "$cachedir" ] || mkdir -p $cachedir
	debug mkfifo $SPLASH_FIFO
	debug splash_util -d -ms -t $theme && SPLASHD=true
	[ -n "$_opts" ] && debug splashd_cmd $_opts
	debug splashd_cmd "set ${mode:-verbose}"
	debug splashd_cmd "set event dev /dev/input/$event"
	debug splashd_cmd "set autoverbose 0"
}

# @FUNCTION: Resume helper (support SwSusp/TuxOnIce)
# @ARG: <[type:]dev[:signature]>
resume() {
	local _asw _dev=$1 _img_sz _hpr
	grep -q $MNTDIR /proc/mounts && debug -d umount -l $MNTDIR

	if [ -d /sys/power/tuxonice ]; then
		if $SPLASHD; then
			[ -n "$theme" ] &&
			debug ln -sf "/etc/splash/$theme" /etc/splash/tuxonice
			_hpr=tuxoniceui_fbsplash
		else
			_hpr=tuxoniceui_text
		fi
		$ENV_CHK && debug -d bin_chk $_hpr && _hpr="$(type -p $_hpr)"

		debug _modprobe tuxonice
		echo $_hpr >/sys/power/tuxonice/user_interface/program
		echo $_dev >/sys/power/tuxonice/resume

		read _img </sys/power/tuxonice/image_exists
		if [ "$_img_sz" = "1" ]; then
			echo >/sys/power/tuxonice/image_exists
		else
			echo >/sys/power/tuxonice/do_resume
		fi
	elif [ -f /sys/power/resume ]; then
		debug _modprobe swsusp
		echo platform >/sys/power/disk # or 'shutdown'  if ACPI does not work
		echo disk >/sys/power/state

		local _node=${_dev#*:}
		[ -h "$_node" ] && _node=$(readlink $_node)
		read _node  </sys/class/block/${_node#*/}/dev
		echo $_node >/sys/power/resume

		read _img_sz </sys/power/image_exists
		if [ "$_img_sz" != "0" ]; then
			echo $_node >/sys/power/resume
		else
			echo 0 >/sys/power/image_size
		fi
	fi
}

# -*- Initialisation -*-

debug umask 0077
debug mkdir -p dev/pts proc run sys $NEWROOT $MNTDIR

debug mount -t proc proc /proc
debug mount -t sysfs sysfs /sys
if grep -q devtmpfs /proc/filesystems; then
	debug mount -t devtmpfs devtmpfs /dev
else
	debug mount -t tmpfs -o exec,mode=755 tmpfs /dev
fi
echo >/dev/mdev.seq
[ -x /sbin/mdev ] && mdev=/sbin/mdev || mdev="/bin/busybox mdev"
debug -d $mdev -s
echo $mdev >/proc/sys/kernel/hotplug

debug mount -t tmpfs -o mode=755,size=1% tmpfs /run
mv -f $LOGFILE /run && export LOGFILE=/run$LOGFILE

CMDLINE="$(cat /proc/cmdline)"
for arg in $CMDLINE; do
	case "$arg" in
		([Rr][Ee][Ss][Cc][Uu][Ee]*|[Rr][Ss][Hh]*) export RSH=1;;
		(ro|rw) export rootflags="${rootflags:+$rootflags,}$arg";;
		(single) export RUNLEVEL=2         ;;
		(hook=*) export HOOKS="${arg#*=}"  ;;
		([Cbcdeiklmnrsz]*=*) export "$arg" ;;
	 esac
done

if [ -n "$level" ]; then
	RSH="${level%:*}"
	CUT "RUNLEVEL" "$level" ":" "2" "-s"
fi

yesno "${env:-YES}"
case $? in
	(1) ENV=false;;
esac
${ENV:-true} && [ -f $CONFDIR/env ] &&
while read _line; do
	case "${_line%%=*}" in
		(CONFDIR|LIBDIR|HOME|KEYMODE|LOGFILE|MNTDIR|NEWROOT|RUNLEVEL|PATH|RSH|SPLASHD|sh) ;;
		(NULL|name) ;;
		([a-zA-Z]*) [ "${env/:${_line%%=*}:}" = "$env" ] && export "$_line" ;;
	esac
done < $CONFDIR/env
$ENV_CHK && debug app_chk

DEBUG="${debug%:*}"
CUT "DMESG" "$debug" ":" "2" "-s"
[ -n "$DEBUG" ]  && set -${DEBUG/e/}
[ -n "$DMESG" ]  && debug dmesg -n $DMESG

[ -f $CONFDIR/boot ] &&
for _m in $(cat $CONFDIR/boot); do
	debug _modprobe $_m
done
for _m in $(echo "$module" | sed 's/:/ /g'); do
	debug _modprobe $_m
done

[ -h /dev/fd     ] || debug ln -fns /proc/self/fd /dev/fd
[ -h /dev/stderr ] || debug ln -fns fd/2 /dev/stderr
[ -h /dev/stdin  ] || debug ln -fns fd/0 /dev/stdin
[ -h /dev/stdout ] || debug ln -fns fd/1 /dev/stdout

:	${CONSOLE:=${console:-/dev/console}}
[ "${CONSOLE/dev}" != "$CONSOLE" ] || CONSOLE="/dev/$CONSOLE"
[ -c $CONSOLE ] || CONFDIR=/dev/console
exec 0<$CONSOLE 1>$CONSOLE 2>&1
export CONSOLE
eval_colors

if [ -n "$splash" ]; then
	begin "Starting Splash"
	splashd
	end "$?"
fi

# -*- Font and keymap -*-

if [ -n "$keymap" ]; then
	CUT "font" "$keymap" "2" ":" "-s"
	kmap="${keymap%:*}"
fi
[ -z "$font" ] && [ -f "$CONFDIR/font" ] && font=$(cat $CONFDIR/font)
[ -z "$kmap" ] && [ -f "$CONFDIR/kmap" ] && kmap=$(cat $CONFDIR/kmap)

[ -n "$font" ] &&
for file in /usr/share/consolefonts/$font*; do
	[ -f "$file" ] && debug loadfont < $file && break
done
[ -n "$kmap" ] &&
for file in /usr/share/keymaps/$kmap*; do
	[ -f "$file" ] && debug loadkmap < $file && break
done
unset file font kmap

level 1

# -*- Logo and or boot message -*-
[ -f /etc/issue.logo ] && cat /etc/issue.logo
debug test -f /etc/msg && clear &&
while read _line; do
	msg -i "$_line"
done </etc/msg

# -*- Hooks -*-
level 2

for hook in bcache btrfs \
	zfs zram; do
	eval test -n \"\$$hook\" && eval HOOKS="$hook $HOOKS"
done
export HOOKS="$(echo $HOOKS | sed -e 's/:/ /g')"
for hook in $HOOKS; do
	if [ -e "$LIBDIR/$hook" ]; then
		debug dohook "$LIBDIR/$hook"
	else
		name=hook error "$hook not found"
	fi
done

# -*- Swap/Resume -*-
# SWAP should be set if available
if [ -n "$swap" ]; then
	level 2s
	if [ -z "$SWAP" ]; then
		begin "Enabling swap device"
		get_dev "$swap" "SWAP" "2"
		end "$?"
	fi
fi
# RESU should be set if available
if [ -n "$resume" ]; then
	level 2r
	if [ -z "$RESU" ] && [ "$resume" != "swap" ]; then
		begin "Starting Resume"
		get_dev "$resume" "RESU" "3"
		end 1
	fi
	debug resume "${RESU:-$SWAP}"
fi

# -*- Root -*-

level 3
# ROOT should be set if available
dorootfs() {
	local FS="${rootfs%:*}" CHK ROOT
	CUT "CHK" "$rootfs" ":" "2" "-s"
	debug -d get_dev "$root" "ROOT" "1"

	level 3f
	if [ -n "$CHK" ]; then
		yesno $CHK && CHK=-d || CHK=-e
		debug $CHK fsck ${FS:+-t$FS} $ROOT
	fi
	level 3m
	debug mount ${rootflags:+-o} $rootflags ${FS:+-t} $FS $ROOT $NEWROOT ||
		die "Failed to mount rootfs"
}
if [ -z "$ROOT" ]; then
	begin "Mounting RootFS"
	dorootfs
	end "$?"
fi
if [ -n "$squashd" ]; then
	level 3s
	begin "Mounting Squashed FileSystems"
	squashd "$squashd"
	end "$?"
fi

# -*- Clean up and switch -*-
level 4

[ -n "$LBD_KEY" ] &&
for _k in $(echo $LBD_KEY | sed '/:/ /g'); do
	debug dmclose "$_k"
done
[ -n "$LBD_DEV" ] &&
for _d in $(echo $LBD_DEV | sed 's/:/ /g'); do
	debug losetup -d $_d
done

[ "$KEYMODE" = "gpg" ] && debug _rmmod gpg
if grep -q $MNTDIR /proc/mounts; then
	debug -d umount -l $MNTDIR
	debug _rmmod remdev
fi

if [ -n "$fsmount" ]; then
	level 4m
	begin "Mounting FileSystems"
	fsmount "$fsmount"
	end "$?"
fi

level 4u
#
# FIXME: is this necessary?
#
$SPLASHD && debug splashd_stop

echo >/proc/sys/kernel/hotplug
for _dir in /run /sys /dev /proc; do
	[ -f $LOGFILE ] || export LOGFILE=/$0.log
	if [ "${SYSFS/${_dir#/}}" != "$SYSFS" ]; then
		begin "Moving $_dir to $NEWROOT"
		mkdir -p $NEWROOT$_dir
		mount -o move $_dir $NEWROOT$_dir >$NULL 2>&1
	else
		begin "Unmounting $_dir"
		umount -l $_dir >$NULL >&1
	fi
	end "$?"
done

level 4s
msg -c GRN "Switching Root"
debug -d exec switch_root $NEWROOT ${init:-/sbin/init} $RUNLEVEL

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
