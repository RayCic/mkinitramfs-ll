#!/bin/sh
# $Header: mkinitramfs-ll/init,v 0.10.2 2012/07/14 18:34:18 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.

export eck=true init=/sbin/init map=root sh=/bin/sh

info() 	{ echo -ne "\033[1;32m * \033[0m$@\n"; }
error() { echo -ne "\033[1;31m * \033[0m$@\n"; }

debug() {
	local _cmd _opt _ret
	[ "$1" = "-d" ] || [ "$1" = "-e" ] || [ "$1" = "-i" ] &&
		_opt=$1 _msg="$2" && shift 2
	_cmd="$@"; $_cmd; _ret=$?
	echo "[$_ret]: $_cmd" >> $logdir/init.log
	if [ ! "$_ret" ]; then
		[ "$_msg" = "--" ] && _msg=
		case $_opt in
			-d) die   "${_msg:-cmd: $_cmd}";;
			-e) error "${_msg:-cmd: $_cmd}";;
			-i) info  "${_msg:-cmd: $_cmd}";;
		esac
	fi
	return "$_ret"
}

rsh() {
	export PS1='rsh:$(tty | cut -c6-):$PWD # '
	if [ $spld ]; then
		debug openvt -c${console#*tty} $sh -i 0<$console 1>$console 2>&1
	elif ack setsid; then debug setsid $sh -i 0<$console 1>$console 2>&1
	else debug $sh -i 0<$console 1>$console 2>&1; fi
}

die() {
	local _ret=$? _msg="Dropping into a rescueshell..."
	[ -n "$@" ] && error "[$_ret]: $@" && msg "[$_ret]: $@"
	info "$_msg"; msg "$_msg"; _stop
	debug rsh || debug exec $sh -i
}

bck() { debug -d -- which $1 &>/dev/null; }
ack() {
	local _app _applets="$@"
	[ -n "$_applets" ] || [ -f /etc/mkinitramfs-ll/busybox.app ] &&
		_applets="$(cat /etc/mkinitramfs-ll/busybox.app)" ||
		debug -d -- busybox --install -s && return
	for _app in $_applets; do 
		[ -h "$_app" ] && [ "$(readlink $_app)" = "/bin/busybox" ] ||
			debug -d -- busybox --install -s && break
	done
}

_rmmod() {
	[ -f "/etc/mkinitramfs-ll/module.$1" ] &&
		local _module="$(cat /etc/mkinitramfs-ll/module.$1)" ||
		local _module="$*"
	for _m in $_module; do debug rmmod $_m; done
}

_modprobe() {
	[ -f "/etc/mkinitramfs-ll/module.$1" ] &&
		local _module="$(cat /etc/mkinitramfs-ll/module.$1)" ||
		local _module="$*"
	for _m in $_module; do debug modprobe $_m; done
}

cmd() { debug echo "$@" >$SPLASH_FIFO; }
verbose() { debug chvt ${console#*tty}; debug cmd "set mode verbose"; }
silent() { debug chvt ${console#*tty}; debug cmd "set mode silent"; }
msg() { [ $spld ] && debug cmd "set message $@" && debug cmd "repaint"; }

_stop() { [ $spld ] && spld=1; debug cmd "exit"; }
spld() {
	$eck && for bin in fbcondecor_helper splash_util; do 
		debug -d -- bck $bin
	done
	local IFS="${IFS}," _opt _opts cachedir event mode msg theme util
	event="$(grep -Hsi keyboard /sys/class/input/input*/name | \
		sed -e 's#.*input\([0-9]*\)/name.*#event\1#')"
	for _opt in $splash; do
	case ${_opt%:*} in
			fad*) _opts="set effects $_opt";;
			silent|verbose) mode=$_opt     ;;
			tty)  console=/dev/${_opt/:/\/};;
			theme) theme=${_opt#*:}        ;;
		esac
	done
	cachedir=/run/splash/cache
	util=$(which splash_util)
:	${BOOT_MSG:="Booting the system (\$progress%)... Press F2 for verbose mode."}
	export BOOT_MSG SPLASH_FIFO=$cachedir/.splash
	[ -d "$cachedir" ] || mkdir -p $cachedir
	debug mkfifo $SPLASH_FIFO
	debug $util -d -ms -t$theme && spld=0
	[ -n "$_opts" ] && debug cmd $_opts
	debug cmd "set event dev /dev/input/$event"
	debug cmd "set autoverbose 0"
	debug ${mode:-verbose}
}

shrl() {
	local _msg="Switching to init shell runlevel: $1"
	info "$_msg"; msg "$_msg"; export shl=$1
	local _scr="$(ls /etc/mkinitramfs-ll.d/$1*-*.sh 2>/dev/null)"
	if [ -n "$_scr" ]; then
		for _s in $_scr; do
			info "exec: $sh -ex $_s..."
			debug $sh -ex $_s
			[ -f /run/env ] && debug source /run/env
			[ -f /run/${_s##*/}.pid ] && rm -f /run/${_s##*/}.pid && debug die
			exec 0<$console 1>$console 2>&1	
		done
	fi
	[ "$shrl" = "$1" ] && debug die
}

_blkid() { eval $2=$(blkid | grep "${1#*=}" | cut -d':' -f1); }

glk() {
	if [ ! "$cld" ]; then
		local _ld="$(debug -d -- losetup -f)"
		debug -d -- losetup "$_ld" "$1"
		ldv="$_ld:$ldv"
	else local _ld="$1"; fi
	debug cryptsetup luksOpen "$_ld" "$_fn" 
	if [ "$?" ]; then
		kfile=/dev/mapper/"$_fn"
		ldk="$_fn:$ldk"
	fi
}

getkey() {
	local _fp="$(echo "$1" | cut -d':' -s -f3)"
	local _kd="$(echo "$1" | cut -d':' -s -f2)"
	local _km="$(echo "$1" | cut -d':' -s -f1)"
	local _dv _fn=${_fp##*/}
	if [ "$_km" != "none" ];then
		if [ -z "$cld" ]; then
			local _v=$(cryptsetup --version | awk '{print $2}')
			[ $(echo "$_v" | cut -d'.' -f2) -ge 3 ] && cld=0
			[ $(echo "$_v" | cut -d'.' -f2) -ge 4 ] && cdh=0
			[ "$cdh" ] && [ $(echo "$_v" | cut -d'.' -f3) -ge 2 ] && cid=0
		fi
	else export kmode=none; return; fi
	if [ "$_km" != "pwd" ]; then
		[ -n "$_kd" ] || die "ik$2=$_km:$_kd:$_fp device field empty"
		[ -n "$_fp" ] || die "ik$2=$_km:$_kd:$_fp filepath field empty"
		debug _blkid "$_kd" "_dv"
		if [ -z "$(mount | grep /mnt/tok)" ]; then
			if [ ! -b "$_dv" ]; then
				sleep 2; debug _blkid "$_kd" "_dv"
				if [ ! -b "$_dv" ]; then
					info "Insert removable device and press Enter."
					read; sleep 2; debug _blkid "$_kd" "_dv"
				fi
				while [ ! -b "$_dv" ]; do
					info "$_dv does not exist, input a valid dev name"
					info "e.g. '[/dev/]sdb1', 'LABEL=<label>' 'UUID=<uuid>'"
					read _dv; sleep 2; debug _blkid "$_dv" "_dv"
				done
			fi
			debug -d -- mount -n -r "$_dv" /mnt/tok
		fi
		debug -d -- test -f "/mnt/tok/$_fp"
	fi
	case $_km in
		gpg) $eck && debug -d -- bck gpg; kfile=/mnt/tok/$_fp; kmode=gpg;;
		reg) kfile="/mnt/tok/$_fp"; kmode=reg;;
		ldk) [ -b "/dev/mapper/$_fn" ] || glk "/mnt/tok/$_fp"; kmode=ldk;;
		pwd) kmode=pwd;;
		*)   die "$_km: keymode is invalid";; 
	esac
	export ${kfile:+kfile} kmode
}

dmclose() { 
	[ -n "$2" ] && debug -d -- vgchange -an ${2%-*}
	local IFS="${IFS}:" 
	for _p in $1; do 
		debug cryptsetup luksClose ${_p%-*} $header ||
			debug cryptsetup remove ${_p%-*} $header
	done
}

dmcrypt() {
	local _apd _asw _cpr _ksz _use
	info "Type a valid LUKS cipher:hash, default is 'aes-xts-plain:sha256'"
	info "you can take something safer like 'aes-cbc-essiv:sha256'"
	read _cpr
	info "Type a valide key-size [256|512], default is 256 bits:"
	read _ksz
	if [ -e "$kfile" ]; then 
		info "use the existing $kfile keyfile? [NO|yes]"
		read _use
		[ "${_use:-no}" = "yes" ] && _use="-d $_use" || _use=
	fi
	if [ -b "$_hdr" ]; then info "use $_hdr detached header [NO|yes]?"
		read _asw
		if [ "${_asw:-no}" = "yes" ]; then info "Enter a valid aligh-payload offset,"
			info "this option is taken as absolute sector alignment and can be zero"
			read _apd; _apd="--align-payload $_apd"
		else unset _hdr; fi
	fi
	debug -d -- cryptsetup $_arg $_dev -c${_cpr:-aes-xts-plain:sha256} \
		-s${_ksz:-256} $_use $_hdr $_apd
}

dmopen() { 
	$eck && debug -d -- bck cryptsetup
	debug _modprobe dm-crypt
	local _arg=luksFormat _asw
	local _map=$(echo "$1" | cut -d'-' -f1)
	local _dev=$(echo "${1#*-}" | cut -d'+' -f1)
	local _hdr=$(echo "$1" | cut -d'+' -s -f2)
	if [ "$cid" ] && [ -n "$(echo "$_dev" | grep -i UUID)" ]; then :;
	else debug -d -- _blkid "$_dev" "_dev"; fi
	if [ -n "$_hdr" ]; then
		if [ -n "$(echo "$_hdr" | grep -E '(UUID|LABEL|sd[a-z][0-9])')" ]; then 
			if [ "$cid" ] && [ -n "$(echo "$_hdr" | grep -i UUID)" ]; then :;
			else debug _blkid "$_hdr" "_hdr"; fi
			debug -d -- test -b "$_hdr" && header="$_hdr" _hdr="--header $_hdr"
		elif [ -e "/mnt/tok/$_hdr" ]; then header="$_hdr" _hdr="--header /mnt/tok/$_hdr"
		else die "$_hdr detached header doesn't exist."; fi
	fi
	debug cryptsetup isLuks "$_dev" "$header"
	if [ ! "$?" ]; then
 		info "cre[ate] $_dev or dec[rypt] another LUKS PV? [cre|DEC]"
		read _asw
		if [ "${_asw:-dec}" = "dec" ]; then
			while true; do
				info "Type in valid LUKS PV e.g. sda5|UUID=<uuid>|LABEL=<label>"
				read _dev; debug _blkid "$_dev" "_dev"
				debug cryptsetup isLuks "$_dev" "$header" && break
			done
		elif [ "$_asw" = "cre" ]; then debug dmcrypt; fi
	fi
	debug -d -- test -n "$_dev" && debug test -b "$_dev" && _arg=luksOpen
	if [ "$kmode" = "gpg" ]; then 
		mv /dev/tty /dev/bak && cp -a /dev/console /dev/tty
		for _i in 1 2 3; do
			debug gpg -qd "$kfile" | cryptsetup "$_arg" "$_dev" "$_map" $_hdr && break
			[ $_i -eq 3 ] && error "...there's still a pwd mode fallback..."
		done
		rm /dev/tty && mv /dev/bak /dev/tty
	elif [ "$kmode" = "ldk" ] || [ "$kmode" = "reg" ]; then 
		debug cryptsetup "$_arg" "$_dev" "$_map" -d "$kfile" $_hdr ||
		error "...there's still a pwd mode fallback..."
	fi
	ctxt=/dev/mapper/$_map
	[ -b "$ctxt" ] || debug -d -- cryptsetup "$_arg" "$_dev" "$_map" "$_hdr"
	debug -d -- test -b $ctxt && eval ${2:-ctxt}=$ctxt
}

lvopen() {
	$eck && debug -d -- bck lvm
	debug _modprobe device-mapper
	local _lv=${1/-//}
	if debug lvchange -ay $_lv; then :;
	elif [ -n "$2" ] && [ "$kmode" != "none" ]; then
		local _pv="$2" IFS="${IFS}:"
		[ -e "/mnt/tok/$_pv" ] && _pv="$(cat /mnt/tok/$_pv)"
		for _p in $_pv; do debug dmopen "$_p"; done
		debug vgchange -ay ${1%-*} || debug -d -- dmclose "$_pv" "$1"
	else die "$1 require a valid crypted physical volume"; fi
	if [ -b "/dev/mapper/$1" ]; then eval ${3-lv}=/dev/mapper/$1
	elif [ -b "/dev/$_lv" ]; then eval ${3-lv}=/dev/$_lv
	else die "$_lv VG/LV do not exist."; fi
}

mdopen() {
	local _dev=${1%*+} _device _opt=$(echo "${1}" | cut -d+ -f2) _set _uuid
	[ -n "$(echo "$_opt" | grep -i uuid)" ] && _uuid=$_opt
	if [ -n "$_uuid" ] || [ -n "$(echo "$_opt" | egrep '^[0-9]')" ]; then
		[ -n "$(echo $_dev | grep dev)" ] || _dev=/dev/$_dev
		[ -b "$_dev" ] && return
		$eck && debug -d -- bck mdadm
		debug _modprobe raid
		if [ -n "$_uuid" ]; then echo ARRAY $_dev $_uuid >>/etc/mdadm.conf
		else echo ARRAY $_dev devices=/dev/sd?${_opt:-*} >>/etc/mdadm.conf;fi
		_conf=-c/etc/mdadm.conf
		debug -d -- mdadm --assemble ${_uuid:+-u${_uuid#*=}} $_conf $_dev
	else
		$eck && debug -d -- bck dmraid
		debug _modprobe dm-raid
		_dev=$(dmraid -r | grep "$_dev" | cut -d':' -f1)
		[ -b "$_dev" ] && return
		for _f in $(echo "$opt" | sed 's/:/ /g'); do
			_set+=" $(dmraid -s -s -c $_f)"
		done
		for _s in ${_dev##*/} $_set; do
			debug -d -- dmraid -ay -i -I $_s
		done
	fi
	debug -d -- test -b $_dev
	eval ${2:-md}=$_dev
}

squashd() {
	local IFS="${IFS}:"
	debug -d -- test -n $sqfsd
	debug -d -- test -d /newroot$sqfsdir
	debug _modprobe sqfsd
	cd /newroot
	for _dir in $sqfsd; do
		local _bdir="$sqfsdir"/$_dir
		debug -d -- test -f .$_bdir.sfs
		debug mkdir -p .$_bdir/rw .$_bdir/ro
		debug -d -- mount -tsquashfs -onodev,loop,ro .$_bdir.sfs .$_bdir/ro &&
		mount -taufs -onodev,udba=reval,br:.$_bdir/rw:.$_bdir/ro $_dir $_dir
	done
}

rootfs() {
	debug -d "iroot=<PV|VG-LV>[:<c>:<fs>] argument is missing" test -n "$iroot"
	local _fscf _dev dev=${iroot%%:*}
	local _fsck="$(echo "$iroot" | cut -d':' -f2)"
	local _fs="$(echo "$iroot" | cut -d':' -f3)"
:	local ${_lvm:=$(echo "$ilvm" | cut -d',' -f1)}
:	local ${_raid:=$(echo "$iraid" | cut -d',' -f1)}
	debug -d -- getkey "${ikroot:-pwd}" "root"
	shrl 3d
	[ -n "$_raid" ] && mdopen "$_raid" "_dev"
	if [ -n "$_lvm" ]; then debug -d -- lvopen "$dev" "$_lvm" "_dev"
	elif [ -n "$kmode" ]; then
		[ "$kmode" != "none" ] && debug -d -- dmopen "${map:-root}-$iroot" "_dev"
		[ "$kmode" == "none" ] && debug -d -- _blkid "$dev" "_dev"
	fi
	shrl 3f
	if [ -n "$_fsck" ]; then 
		[ "$_fsck" = "n" ] || [ "$_fsck" = "no" ] && _fscf="-e" || _fscf="-d"
		debug $_fscf fsck ${_fs:+-t$_fs} $_dev 
	fi
	shrl 3m
	if [ -z "$rootfs" ]; then
		debug mount ${imopt:+-o$imopt} ${_fs:+-t$_fs} $_dev /newroot ||
		[ -n "$kmode" ] && debug -d -- dmclose "${_lvm:-${map:-root}}" "${_lvm:+${_dev##*/}}"
		die "failed to mount rootfs"
	fi
	shrl 3s
	[ -n "$sqfsd" ] && debug -d -- squashd
	unset imopt iroot ikroot kmode sqfsdir sqfsd
}

swap() {
	debug -d "i$1=<type>:<PV|VG-LV>[:<sign>] argument is missing" test -n "$2"
	local _swp="$3" _type="${1%%:*}" _dev
	local dev="$(echo "$1" | cut -d':' -s -f2)" 
	local _sign="$(echo "$1" | cut -d':' -s -f3)"
	debug -d -- getkey "${2:-pwd}" "$_swp"
	[ -n "$_raid" ] && debug -d -- mdopen "$_raid" "_dev"
	if [ -n "$_lvm" ]; then debug -d -- lvopen "$dev" "$_lvm" "_dev"
	elif [ "$kmode" != "none" ]; then debug -d -- dmopen "$_swp-$dev" "_dev"
	elif [ "$kmode" == "none" ]; then debug -d -- _blkid "$dev" "_dev"; fi
	[ -n "$4" ] && eval ${4:-swp}=$_type:$_dev${_sign+:$_sign}
	unset i$1 ik$1 kmode
}

resume() {
	local _asw _dev _img _msg _toi _spd
	_msg="Resuming from hibernation..."
	info "$_msg"; msg "$_msg"
	if [ -n "$(echo "$iresume" | cut -d':' -s -f2)" ]; then
:		local ${_raid:=$(echo "$iraid" | cut -d',' -f3)}
:		local ${_lvm:=$(echo "$ilvm" | cut -d',' -f3)}
		debug -d -- swap "$iresume" "$ikresume" "resume" "_dev"
	fi
	debug -d -- mount -n -o remount,ro /newroot
	if [ -d /sys/power/tuxonice ]; then
		_toi="$(which tuxoniceui_text)"
:		${_toi:=$(which tuxoniceui_fbsplash)}
		debug _modprobe tuxonice
		debug -d -- "echo $_dev >/sys/power/tuxonice/resume"
		_i="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "toi: no recognizable signature at the pointed location"
			error "toi: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "toi: resume aborted"
		else die "toi: no image found at the pointed location"; fi
		if [ -n "$theme" ]; then
			debug ln -sf "/etc/splash/$theme" /etc/splash/tuxonice
		fi
		_stop
		debug -d -- "echo $_toi >/sys/power/tuxonice/user_interface/program"
		debug -d -- "echo >/sys/power/tuxonice/do_resume"
		debug -d -- "echo >/sys/power/tuxonice/image_exists"
		debug _rmmod tuxonice
	elif [ -f /sys/power/resume ]; then
		_spd="$(which suspendui_text)"
:		${_spd:=$(which suspendui_fbsplash)}
		debug _modprobe swsusp
		debug -d -- "echo $_dev >/sys/power/disk/resume"
		_img="$(cat /sys/power/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "suspend: no recognizable signature at the pointed location"
			error "suspend: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "suspend: resume aborted"
		else die "suspend: no image found at the pointed location"; fi
		_stop
		debug -d -- "echo disk >/sys/power/state"
		debug _rmmod swsusp
	else error "no suspend/hibernation support found"; fi
	debug -d -- mount -n -o remount,rw /newroot
	die "failed to resume from hibernation"
}

imount() {
	local _fs _dev _mpt _opt _x _y _z IFS="${IFS}:"
	for _x in $imount; do
		_y="$(grep $_x /newroot/etc/fstab)"
		if [ -n "${y}" ]; then
			 _fs=$(echo "$_y" | awk '{print $3}')
			_dev=$(echo "$_y" | awk '{print $1}')
			_mpt=$(echo "$_y" | awk '{print $2}')
			_opt=$(echo "$_y" | awk '{print $4}')
		else
			error "$_x not found in fstab"
			break
		fi
		for _z in 0 1 2 3 4; do
			[ "$_opt" = "$_z" ] && _opt=
		done
		debug -d -- test -b $_dev
		debug -d -- test -d $_mpt
		debug -d -- mount -t$_fs ${_opt:+-o$_opt} $_dev /newroot/$_mpt
	done
}

switch() {
	debug 'echo >/proc/sys/kernel/hotplug'
	local _msg="Switching / ..."
	info "$_msg"; msg "$_msg"
	debug _stop
	sleep 1
	shrl 4u
	debug -d -- umount -l /proc
	debug -d -- umount -l /sys
	debug -d -- umount -l /dev/pts
	debug -d -- umount -l /dev
	debug -e -- umount -l /run
	shrl 4s
	debug -d -- exec switch_root /newroot ${init:-/sbin/init} $rirl
}

main() {
	debug _init
	local _font=$(echo "$ikmap" | cut -d':' -f2)
	local _kmap=$(echo "$ikmap" | cut -d':' -f1)
	if [ -n "$_kmap" ]; then
		for _dir in /usr/share/keymaps /etc /; do
			if [ -f "$_dir/$_kmap" ]; then
				debug -d -- loadkmap < "$_dir/$_kmap" && break
			fi
		done
	fi
	if [ -n "$_font" ]; then
		for _dir in /usr/share/consolefonts /etc /; do
			if [ -f "$_dir/$_font" ]; then
				debug -e -- loadfont < "$_dir/$_font" && break
			fi
		done
	fi
	debug test -f /etc/msg && clear && while read _line; do
		info "$_line"; msg "$_line"
	done < /etc/msg
	debug _modprobe gpg
	debug _modprobe remdev
	shrl 1
	if [ -n "$iswap" ]; then
:		local ${_raid:=$(echo "$iraid" | cut -d',' -f2)}
:		local ${_lvm:=$(echo "$ilvm" | cut -d',' -f2)}
		shrl 2s
		swap "$iswap" "$ikswap" "swap"
	fi
	[ -n "$iresume" ] && shrl 2r && debug resume
	debug rootfs
	shrl 4c
	local IFS="${IFS}:"
	for _k in $ldk; do debug dmclose "$_k"; done
	for _d in $ldv; do debug losetup -d $_d; done
	debug _rmmod gpg
	debug -e -- umount -f -l /mnt/tok
	debug _rmmod remdev
	[ -n "$imount" ] && shrl 4m && debug imount
	debug switch
}

_getopts() {
	for arg in $(cat /proc/cmdline); do
    		case $arg in
			rescue*)  shrl=1;;
			single)   rirl=2;;
			isqfsd=*) export $arg
				if [ "${isqfsd%,*}" = "y" ]; then sqfsdir=${sqfsdir:-/sqfsd}
				else sqfsdir=${isqfsd%,*}; fi
				if [ "${isqfsd#*,}" = "y" ]; then sqfsd=${sqfsd:-usr:opt:bin:sbin}
				elif [ "$(echo ${isqfsd#*,}|cut -d':' -f1)" = "a" ]; then
					sqfsd=${sqfsd:-usr:opt:bin:sbin}:$(echo ${isqfsd#*,} | cut -c3-)
				else sqfsd=$(echo ${isqfsd#*,} | cut -c3-); fi;;
			*init=*)  export init=${arg#*=};;
			ishrl=*)  shrl=$(echo ${arg#*=}|cut -d':' -f1)
				      rirl=$(echo ${arg#*=}|cut -d':' -f2);;
			dmesg|ikmap*|ilvm*|imo*|*root*|*resume*|*swap*|splash*) export $arg;;
	   	 esac
	done
}

_init() {
	debug export PATH=/sbin:/bin:/usr/bin:/usr/sbin HOME=/root
	debug umask 0077
	cat </init|sed '/^#.*$/d'|tail -n+4|head -n302  >>/lib/mkinitramfs-ll/fbase.sh
	sed -e 's/debug\ rsh.*$/exit\ \$_ret/'         -i /lib/mkinitramfs-ll/fbase.sh
	[ -f /etc/profile ] && . /etc/profile
	debug -d -- mkdir -p dev/pts proc run sys newroot mnt/tok
	debug -d -- mount -t proc proc /proc
	debug -d -- mount -t tmpfs -o mode=755 tmpfs /run
	debug -d -- mkdir -p /run/log && export logdir=/run/log
	debug mv -f /init.log $logdir
	$eck && debug ack
	debug -d -- mount -t sysfs sysfs /sys
	debug _getopts
	[ -n "$dmesg" ] && debug dmesg -n $dmesg
	debug _modprobe boot
	if grep devtmpfs /proc/filesystems &>/dev/null; then
		debug -d -- mount -t devtmpfs devtmpfs /dev
	else debug -d -- mount -t tmpfs tmpfs /dev; fi
	debug mkdir /dev/pts
	debug mount -t devpts -o gid=5,mode=0620 devpts /dev/pts
	echo >/dev/mdev.seq
	debug -d -- mdev -s
	echo /sbin/mdev >/proc/sys/kernel/hotplug
	if [ -n "$mod" ]; then local IFS="${IFS},"
		for _m in $mod; do 
			debug modprobe $_m
		done
	fi
	[ -h /dev/fd     ] || debug ln -fs /proc/self/fd   /dev/fd
	[ -n /dev/stderr ] || debug ln -fs /proc/self/fd/2 /dev/stderr
	[ -n /dev/stdin  ] || debug ln -fs /proc/self/fd/0 /dev/stdin
	[ -n /dev/stdout ] || debug ln -fs /proc/self/fd/1 /dev/stdout
:	${console:=/dev/tty1}
	[ -n "$(echo $console | grep /dev)" ] || console="/dev/$tty"
	exec 0<$console 1>$console 2>&1
	export console
	[ -n "$splash" ] && debug spld
}

main

# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
