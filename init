#!/bin/sh
# $Header: mkinitramfs-ll/init,v 0.8.1 2012/06/13 13:48:14 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.
#
# user defined variables
init=/sbin/init # real init to execute after switching to real root
eck=1           # test if env binaries exist in PATH
rmp=root        # root mapping for dmcrypt
# default values [edit at your own risk]
spld=1
srl=0
# functions
info() 	{ echo -ne "\033[1;32m * \033[0m$@\n"; }
error() { echo -ne "\033[1;31m * \033[0m$@\n"; }

debug() {
	local _cmd _opt _ret
	[ "$1" = "-d" ] || [ "$1" = "-e" ] || [ "$1" = "-i" ] && _opt=$1 && shift
	_cmd="$@"; $_cmd; _ret=$?
	echo "[$_ret]: ${_cmd:-$@}" >> /run/log/init.log
	if [ ! "$_ret" ]; then
		case $_opt in
			-d) die "d[$_ret]: $_cmd";;
			-e) error "e[$_ret]: $_cmd";;
			-i) info "i[$_ret]: $_cmd";;
		esac
	fi
	return "$_ret"
}

rsh() {
	export PS1='rsh:$(tty | cut -c6-):$PWD # '
	if [ "$spld" ]; then
		debug openvt -c${tty#*tty} sh -i 0<$tty 1>$tty 2>&1
	elif ack setsid; then debug setsid sh -i 0<$tty 1>$tty 2>&1
	else debug sh -i 0<$tty 1>$tty 2>&1; fi
}

die() {
	local _msg="Dropping into a rescueshell..."
	debug umount -fl /mnt/tok &>/dev/null
	[ -n "$@" ] && error "$@" && spl_msg "$@"
	info "$_msg"; spl_msg "$_msg"
	for _k in $ldk; do debug dmclose "$_k"; done
	for _d in $ldv; do debug losetup -d "$_d"; done
	debug rsh || debug exec sh -i
}

bck() { debug -d which $1 &>/dev/null; }
ack() {
	local _app _applets="$@"
	[ -n "$_applets" ] || [ -f /etc/mkinitramfs-ll/busybox.app ] &&
		_applets="$(cat /etc/mkinitramfs-ll/busybox.app)" || busybox --install -s
	for _app in $_applets; do 
		[ -h "$_app" ] && [ "$(readlink $_app)" = "/bin/busybox" ] ||
			debug -d busybox --install -s && break
	done
}

_rmmod() {
	if [ -f "/etc/mkinitramfs-ll/module.$1" ]; then
		for _m in $(cat /etc/mkinitramfs-ll/module.$1); do 
			debug rmmod $_m
		done
	fi
}

_modprobe() {
	if [ -f "/etc/mkinitramfs-ll/module.$1" ]; then
		for _m in $(cat /etc/mkinitramfs-ll/module.$1); do 
			debug modprobe $_m
		done
	fi
}

spl_cmd() { debug echo "$@" > $SPLASH_FIFO; }
spl_verbose() { debug chvt ${tty#*tty}; debug spl_cmd "set mode verbose"; }
spl_silent() { debug chvt ${tty#*tty}; debug spl_cmd "set mode silent"; }
spl_msg() { [ "$spld" ] && debug spl_cmd "set message $@" && debug spl_cmd "repaint"; }

spld_stop() { [ "$spld" ] && spld=1; debug spl_cmd "exit"; }
spld_init() {
	[ -n "$(echo "$spl" | grep fadein)" ] && local _opt="-c set effects fadein"
:	${tty:=tty1}
	spl_mode=${spl%%,*}
	spl_cachedir=/run/splash/cache
	spl_util=splash_util
	export SPLASH_FIFO=$spl_cachedir/.splash
	[ "$eck" ] && debug bck $spl_uil
	[ ! -d "$spl_cachedir" ] && mkdir -p $spl_cachedir
	debug mkfifo $SPLASH_FIFO
	debug $spl_util $_opt -d -t "$theme" && spld=0
	debug spl_cmd "set event dev evdev"
	[ "${spl_mode:-verbose}" = "verbose" ] && spl_verbose || spl_silent
}

isrl() {
	local _msg="Switching to init shell runlevel: $1"
	info "$_msg"; spl_msg "$_msg"
	local _scr="$(ls /etc/local.d/${1}?-*.sh &> /dev/null)"
	if [ -n "$_scr" ]; then
		for _s in $_scr; do 
			info "exec: sh -ex $_s..."
			debug -e sh -ex $_s
		done
	fi
	[ "$srl" = "$1" ] && debug die
}

_blkid() { eval $2=$(blkid | grep "${1#*=}" | cut -d':' -f1); }

getldk() {
	if [ ! "$cld" ]; then
		local _ld="$(debug -d losetup -f)"
		debug -d losetup "$_ld" "$1"
		ldv="$_ld:$ldv"
	else local _ld="$1"; fi
	debug cryptsetup luksOpen "$_ld" "$_fn" 
	if [ "$?" ]; then
		kfile=/dev/mapper/"$_fn"
		ldk="$_fn:$ldk"
	fi
}

getkey() {
	local _fp="$(echo "$1" | cut -d':' -s -f3)"
	local _kd="$(echo "$1" | cut -d':' -s -f2)"
	local _km="$(echo "$1" | cut -d':' -s -f1)"
	local _dv _fn=${_fp##*/}
	if [ -n "$_km" ]; then 
		if [ "$_km" != "none" ];then
			if [ -z "$cld" ]; then
				local _v=$(cryptsetup --version | awk '{print $2}')
				[ $(echo "$_v" | cut -d'.' -f2) -ge 3 ] && cld=0
				[ $(echo "$_v" | cut -d'.' -f2) -ge 4 ] && cdh=0
				[ "$cdh" ] && [ $(echo "$_v" | cut -d'.' -f3) -ge 2 ] && cid=0
			fi
		else return; fi
	else return; fi
	if [ "$_km" != "pwd" ]; then
		[ -n "$_kd" ] || die "ik$2=$_km:$_kd:$_fp device field empty"
		[ -n "$_fp" ] || die "ik$2=$_km:$_kd:$_fp filepath field empty"
		debug _blkid "$_kd" "_dv"
		if [ -z "$(mount | grep /mnt/tok)" ]; then
			if [ ! -b "$_dv" ]; then
				sleep 2; debug _blkid "$_kd" "_dv"
				if [ ! -b "$_dv" ]; then
					info "Insert removable device and press Enter."
					read; sleep 2; debug _blkid "$_kd" "_dv"
				fi
				while [ ! -b "$_dv" ]; do
					info "$_dv does not exist, input a valid dev name"
					info "e.g. '[/dev/]sdb1', 'LABEL=<label>' 'UUID=<uuid>'"
					read _dv; sleep 2; debug _blkid "$_dv" "_dv"
				done
			fi
			debug -d mount -n -r "$_dv" /mnt/tok
		fi
		debug -d test -f "/mnt/tok/$_fp"
	fi
	case $_km in
		gpg) [ "$eck" ] && bck "gpg"; kfile="/mnt/tok/$_fp"; kmode=gpg;;
		reg) kfile="/mnt/tok/$_fp"; kmode=reg;;
		ldk) [ -e "/dev/mapper/$_fn" ] || getldk "/mnt/tok/$_fp"; kmode=ldk;;
		pwd) kmode=pwd;;
		*)   die "$_km: keymode is invalid";; 
	esac
}

dmclose() { 
	[ -n "$2" ] && debug -d vgchange -an ${2%-*}
	local IFS="${IFS}:" 
	for _p in $1; do 
		debug cryptsetup luksClose ${_p%%-*} $header ||
			debug cryptsetup remove ${_p%%-*} $header
	done
}

dmcrypt() {
	local _apd _asw _cpr _ksz _use
	info "Type a valid LUKS cipher:hash, default is 'aes-xts-plain:sha256'"
	info "you can take something safer like 'aes-cbc-essiv:sha256'"
	read _cpr
	info "Type a valide key-size [256|512], default is 256 bits:"
	read _ksz
	if [ -e "$kfile" ]; then 
		info "use the existing $kfile keyfile? [NO|yes]"
		read _use
		[ "${_use:-no}" = "yes" ] && _use="-d $_use" || _use=
	fi
	if [ -b "$_hdr" ]; then info "use $_hdr detached header [NO|yes]?"
		read _asw
		if [ "${_asw:-no}" = "yes" ]; then info "Enter a valid aligh-payload offset,"
			info "this option is taken as absolute sector alignment and can be zero"
			read _apd; _apd="--align-payload $_apd"
		else _hdr=; fi
	fi
	debug -d cryptsetup $_arg $_dev -c${_cpr:-aes-xts-plain:sha256} \
		-s${_ksz:-256} $_use $_hdr $_apd
}

dmopen() { 
	[ "$eck" ] && bck "cryptsetup"
	local _arg=luksFormat _asw
	local _map=$(echo "$1" | cut -d'-' -f1)
	local _dev=$(echo "${1#*-}" | cut -d'+' -f1)
	local _hdr=$(echo "$1" | cut -d'+' -s -f2)
	if [ "$cid" ] && [ -n "$(echo "$_dev" | grep -i UUID)" ]; then continue
	else debug -d _blkid "$_dev" "_dev"; fi
	if [ -n "$_hdr" ]; then
		if [ -n "$(echo "$_hdr" | grep -E '(UUID|LABEL|sd[a-z][0-9])')" ]; then 
			if [ "$cid" ] && [ -n "$(echo "$_hdr" | grep -i UUID)" ]; then continue
			else debug _blkid "$_hdr" "_hdr"; fi
			debug -d test -b "$_hdr" && header="$_hdr" _hdr="--header $_hdr"
		elif [ -e "/mnt/tok/$_hdr" ]; then header="$_hdr" _hdr="--header /mnt/tok/$_hdr"
		else die "$_hdr detached header doesn't exist."; fi
	fi
	debug cryptsetup isLuks "$_dev" "$header"
	if [ ! "$?" ]; then
 		info "cre[ate] $_dev or dec[rypt] another LUKS PV? [cre|DEC]"
		read _asw
		if [ "${_asw:-dec}" = "dec" ]; then
			while true; do
				info "Type in valid LUKS PV e.g. sda5|UUID=<uuid>|LABEL=<label>"
				read _dev; debug _blkid "$_dev" "_dev"
				debug cryptsetup isLuks "$_dev" "$header" && break
			done
		elif [ "$_asw" = "cre" ]; then debug dmcrypt; fi
	fi
	debug -d test -b "$_dev" && _arg=luksOpen
	if [ "$kmode" = "gpg" ]; then 
		mv /dev/tty /dev/bak && cp -a /dev/console /dev/tty
		for _i in 1 2 3; do
			debug gpg -qd "$kfile" | cryptsetup "$_arg" "$_dev" "$_map" $_hdr && break
			[ $_i -eq 3 ] && error "...there's still a pwd mode fallback..."
		done
		rm /dev/tty && mv /dev/bak /dev/tty
	elif [ "$kmode" = "ldk" ] || [ "$kmode" = "reg" ]; then 
		debug cryptsetup "$_arg" "$_dev" "$_map" -d "$kfile" $_hdr ||
		error "...there's still a pwd mode fallback..."
	fi
	local _dv=/dev/mapper/$_map
	[ ! -b "$_dv" ] || debug -d cryptsetup "$_arg" "$_dev" "$_map" "$_hdr"
	debug -d test -b $_dv && eval $2=$_dv
}

lvopen() {
	[ "$eck" ] && bck "lvm"
	local _lv=${1/-//}
	if debug lvchange -ay $_lv; then continue
	elif [ -n "$2" ]; then
		local _pv="$2" IFS="${IFS}:"
		[ -e "/mnt/tok/$_pv" ] && _pv="$(cat /mnt/tok/$_pv)"
		for _p in $_pv; do debug dmopen "$_p"; done
		debug vgchange -ay ${1%-*} || debug -d dmclose "$_pv" "$1"
	else die "$1 require a valid crypted physical volume"; fi
	if [ -b "/dev/mapper/$1" ]; then eval $3=/dev/mapper/$1
	elif [ -b "/dev/$_lv" ]; then eval $3=/dev/$_lv
	else die "$_lv VG/LV do not exist."; fi
}

mdopen() {
	local _dev=${1%%-*} _prt=$(echo "$1" | cut -d'+' -f2)
	[ -n "$(echo $_dev | grep /dev)" ] || _dev=/dev/$_dev
	[ -b "$_dev" ] && return
	if [ -n "$(echo $1 | grep UUID)" ]; then
		if [ -n "$_prt" ]; then
			echo DEVICE $(ls /dev/sd*$_prt) >> /etc/mdadm.conf
		else echo 'DEVICE /dev/sd??*' >> /etc/mdadm.conf; fi
		echo ARRAY $_dev $(echo "${1#*-}" | cut -d'+' -f1) >> /etc/mdadm.conf
	fi
	debug mdadm --assemble --scan "$_dev" || raidautorun
	debug -d test -b "$_dev"
}

sqfsd() {
	local IFS="${IFS}:" _rd=${sqfsdir}
	debug -d test -n $_rd
	debug -d test -n $sqfsd
	debug -d test -d /newroot$_rd
	debug _modprobe sqfsd
	cd /newroot
	for _d in $sqfsd; do
		debug -d test -f .$_rd/$_d.sfs
		mkdir -p .$_rd/$_d/rw; mkdir -p .$_rd/$_d/ro
		debug -d mount -tsquashfs -onodev,loop,ro .$_rd/$_d.sfs .$_rd/$_d/ro &&
		mount -taufs -onodev,udba=reval,br:.$_rd/$_d/rw:.$_rd/$_d/ro $_d $_d
	done
}
rootfs() {
	[ -n "$root" ] || die "iroot=<PV|VG-LV>[:<c>:<fs>] argument is missing"
	local _dev _fscf _rdev=${root%%:*}
	local _fsck="$(echo "$root" | cut -d':' -f2)"
	local _fs="$(echo "$root" | cut -d':' -f3)"
:	local ${_lvm:=$(echo "$lvm" | cut -d',' -f1)}
:	local ${_raid:=$(echo "$raid" | cut -d',' -f1)}
	debug getkey "$kroot" "root"
	isrl 3d
	[ -n "$_raid" ] && mdopen "$_raid"
	if [ -n "$_lvm" ]; then debug -d lvopen "$_rdev" "$_lvm" "_dev"
	elif [ -n "$kmode" ]; then debug -d dmopen "${rmp:-root}-$root" "_dev"
	else debug -d _blkid "$_rdev" "_dev"; fi
	isrl 3f
	if [ -n "$_fsck" ]; then 
		if [ "$_fsck" = "n" ] || [ "$_fsck" = "no" ]; then _fscf="-e"
		else _fscf="-d"; fi
		debug $_fscf fsck ${_fs:+-t$_fs} $_dev 
	fi
	isrl 3m
	debug mount ${mopt:+-o$mopt} ${_fs:+-t$_fs} $_dev /newroot
	if [ ! "$?" ]; then
		if [ -n "$kmode" ]; then
			debug -d dmclose "${_lvm:-${rmp:-root}}" "${_lvm:+$_rdev}"
		fi
		die "failed to mount rootfs"
	fi
	isrl 3s
	[ -n "$sqfsd" ] && debug -d sqfsd
	_lvm=; mopt=; kmode=
}

swap() {
	[ -n "$2" ] || die "i$1=<type>:<PV|VG-LV>[:<sign>] argument is missing"
	local _dev _swp="$1"  _type="${2%%:*}"
	local _hdev="$(echo "$2" | cut -d':' -s -f2)" 
	local _sign="$(echo "$2" | cut -d':' -s -f3)"
	debug getkey "$_swp" "$3"
	[ -n "$_raid" ] && debug -d mdopen "$_raid"
	if [ -n "$_lvm" ]; then debug -d lvopen "$_hdev" "$_lvm" "_dev"
	elif [ -n "$kmode" ]; then debug -d dmopen "$_swp-$_hdev" "_dev"
	else debug -d _blkid "$_hdev" "_dev"; fi
	[ -n "$4" ] && eval $4=$_type:$_dev${_sign+:$_sign}
	_lvm=; _raid=; kmode=
}

resume() {
	local _asw _dev _img _msg _toi _spd
	_msg="Resuming from hibernation..."
	info "$_msg"; spl_msg "$_msg"
	if [ -n "$(echo "$toi" | cut -d':' -s -f2)" ]; then
:		local ${_raid:=$(echo "$raid" | cut -d',' -f3)}
:		local ${_lvm:=$(echo "$lvm" | cut -d',' -f3)}
		debug -d swap "resume"  "$toi" "$kresume" "_dev"
	fi
	debug -d mount -n -o remount,ro /newroot
	if [ -d /sys/power/tuxonice ]; then
		_toi="$(which tuxoniceui_text)"
:		${_toi:=$(which tuxoniceui_fbsplash)}
		debug _modprobe tuxonice
		debug -d echo $_dev > /sys/power/tuxonice/resume
		_i="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "toi: no recognizable signature at the pointed location"
			error "toi: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "toi: resume aborted"
		else die "toi: no image found at the pointed location"; fi
		if [ -n "$theme" ]; then
			ln -sf "/etc/splash/$theme" /etc/splash/tuxonice
		fi
		spld_stop
		echo $_toi > /sys/power/tuxonice/user_interface/program
		debug -d echo > /sys/power/tuxonice/do_resume
		debug -d echo > /sys/power/tuxonice/image_exists
		debug _rmmod tuxonice
	elif [ -f /sys/power/resume ]; then
		_spd="$(which suspendui_text)"
:		${_spd:=$(which suspendui_fbsplash)}
		debug _modprobe suspend
		debug -d echo ${_dev} > /sys/power/disk/resume
		_img="$(cat /sys/power/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "suspend: no recognizable signature at the pointed location"
			error "suspend: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "suspend: resume aborted"
		else die "suspend: no image found at the pointed location"; fi
		spld_stop
		debug -d echo disk > /sys/power/state
		debug _rmmod suspend
	else error "no suspend/hibernation support found"; fi
	debug -d mount -n -o remount,rw /newroot
	die "failed to resume from hibernation"
}

imount() {
	local _fs _dev _mpt _opt _x _y _z IFS="${IFS}:"
	for _x in $mount; do
		_y="$(grep $_x /newroot/etc/fstab)"
		if [ -n "${y}" ]; then
			 _fs=$(echo "$_y" | awk '{print $3}')
			_dev=$(echo "$_y" | awk '{print $1}')
			_mpt=$(echo "$_y" | awk '{print $2}')
			_opt=$(echo "$_y" | awk '{print $4}')
		else
			error "$_x not found in fstab"
			break
		fi
		for _z in 0 1 2 3 4; do
			[ "$_opt" = "$_z" ] && _opt=
		done
		debug -d test -b $_dev
		debug -d test -d $_mpt
		debug -d mount -t$_fs ${_opt:+-o$_opt} $_dev /newroot/$_mpt
	done
}

switch() {
	echo > /proc/sys/kernel/hotplug
	local spl_msg="Switching / ..."
	info "$_msg"; spl_msg "$_msg"
	debug spld_stop
	sleep 1
	isrl 4u
	debug -d umount -l /proc
	debug -d umount -l /sys
	debug -d umount -l /dev
	isrl 4s
	debug -d exec switch_root /newroot ${init:-/sbin/init} $irl
}

imsg() { [ -e /etc/msg ] && info "$(cat /etc/msg)"; }

main() {
	if [ -n "$kmap" ]; then
		for _dir in /usr/share/keymaps /etc /; do
			if [ -f "$_dir/$kmap" ]; then
				debug -d loadkmap < "$_dir/$kmap" && break
			fi
		done
	fi
	if [ -n "$font" ]; then
		for _dir in /usr/share/consolefonts /etc /; do
			if [ -f "$_dir/$font" ]; then
				debug -e loadfont < "$_dir/$font" && break
			fi
		done
	fi
	debug imsg
	isrl 1
	debug _modprobe gpg
	debug _modprobe remdev
	if [ -n "$swap" ]; then
:		local ${_raid:=$(echo "$raid" | cut -d',' -f2)}
:		local ${_lvm:=$(echo "$lvm" | cut -d',' -f2)}
		isrl 2s
		swap "swap" "$swap" "$kswap"
	fi
	[ -n "$toi" ] && isrl 2r && debug resume
	debug rootfs
	isrl 4c
	local IFS="${IFS}:"
	for _k in $ldk; do debug dmclose "$_k"; done
	for _d in $ldv; do debug losetup -d $_d; done
	debug _rmmod gpg
	debug -d umount -n -l /mnt/tok
	debug _rmmod remdev
	[ -n "$imount" ] && isrl 4m && debug imount
	debug switch
}

_getopts() {
	local dir
	for arg in $(cat /proc/cmdline); do
    		case $arg in
			rescue*)    srl=1;;
			single)     irl=2;;
			isqfsd=*)   dir=${arg#*=}
				if [ "${dir%,*}" = "y" ]; then sqfsdir=${sqfsdir:-/sqfsd}
				else sqfsdir=${dir%,*}; fi
				if [ "${dir#*,}" = "y" ]; then sqfsd=${sqfsd:-usr:opt:bin:sbin}
				elif [ "$(echo ${dir#*,}|cut -d':' -f1)" = "a" ]; then
					sqfsd=${sqfsd:-usr:opt:bin:sbin}:$(echo ${dir#*,} | cut -c3-)
				else 	sqfsd=$(echo ${dir#*,} | cut -c3-); fi;;
			iroot=*)    root=${arg#*=};;
			iraid=*)    raid=${arg#*=};;
			*init=*)    init=${arg#*=};;
			ilvm=*)     lvm=${arg#*=};;
			imod=*)     mod=${arg#*=};;
			imopt=*)    mopt=${arg#*=};;
			splash=*)   dir=${arg#*=}; theme=${dir#*:}; spl=${dir%,*};;
			console=*)  tty=${arg#*=};;
			iresume=*)  toi=${arg#*=};;
			ikmap=*)    kmap=$(echo ${arg#*=}|cut -d':' -f1)
				        font=$(echo ${arg#*=}|cut -d':' -f2);;
			ishrl=*)    srl=$(echo ${arg#*=}|cut -d':' -f1)
				        irl=$(echo ${arg#*=}|cut -d':' -f2);;
			iswap=*)    swap=${arg#*=};;
			ikroot=*)   kroot=${arg#*=};;
			ikswap=*)   kswap=${arg#*=};;
			imount=*)   imount=${arg#*=};;
			ikresume=*) kresume=${arg#*=};;
	   	 esac
	done
}

_init() {
	export PATH=/sbin:/bin:/usr/bin:/usr/sbin HOME=/root
	umask 0077
	for dir in dev proc run sys newroot mnt/tok; do mkdir -p /$dir; done
	mount -tproc -orw,nosuid,nodev,noexec,relatime proc /proc
	mount -ttmpfs -orw,nosuid,nodev,relatime,mode=755 tmpfs /run
	mkdir /run/log
	[ "$eck" ] && ack
	debug -d mount -tsysfs -orw,nosuid,nodev,noexec,relatime sysfs /sys
	debug _getopts
	debug _modprobe boot
	debug -d mount -ttmpfs -orw,nosuid,nodev,noexec,relatime tmpfs /dev
	debug -d mdev -s
	debug -d echo /sbin/mdev > /proc/sys/kernel/hotplug
	if [ -n "$mod" ]; then local IFS="${IFS},"
		for _m in $mod; do 
			debug modprobe $_m
		done
	fi
	[ -h /dev/fd     ] || debug ln -fs /proc/self/fd   /dev/fd
	[ -n /dev/stderr ] || debug ln -fs /proc/self/fd/2 /dev/stderr
	[ -n /dev/stdin  ] || debug ln -fs /proc/self/fd/0 /dev/stdin
	[ -n /dev/stdout ] || debug ln -fs /proc/self/fd/1 /dev/stdout
:	${tty:=/dev/console}
	[ -n "$(echo $tty | grep /dev)" ] || tty="/dev/$tty"
#	debug exec 0<$tty 1>$tty 2>&1
	[ -n "$spl" ] && spld_init
	debug main
}
debug _init

# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
