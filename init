#!/bin/sh
#
# $Header: mkinitramfs-ll/init                           Exp $
# $Author: (c) 2011-2015 -tclover <tokiclover@gmail.com> Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 0.16.2 2015/01/10 12:33:03                   Exp $
#
# WARNING: USE AT YOUR OWN RISK! EVERYTHING IS GIVEN “AS IS”, SEE COPYING FILE
#

# Enable ChecKing binaries & busybox applets
:   ${ECK=true}
# Set real (path to) init
:   ${init=/sbin/init}
# Set configuration directory path
:   ${CONFDIR=/etc/mkinitramfs-ll}
# Set library directory path
:   ${LIBDIR=/lib/mkinitramfs-ll}
# Set SHell to use
:   ${sh=/bin/sh}
# Set log file to use (for debugging)
:   ${LOGFILE=$0.log}
# Set mount point to use for removable token or device
:   ${MNTDIR=/mnt/tok}
# Set New root directory to switch root
:   ${NEWROOT=/newroot}
# Set SPLash Daemon running state
:   ${SPLD=false}

export CONFDIR LIBDIR LOGFILE MNTDIR NEWROOT SPLD init sh
export HOME=/root PATH=/sbin:/bin:/usr/bin:/usr/sbin
export PS1='-(rsh:$(tty | cut -c6-):$PWD)-# ' PS2='-# '

# @DESCRIPTION: Helper to handle fatal errors
# @USAGE: <msg>
die() {
	local _ret=$?
	[ -n "$@" ] && msg -e "[$_ret]: $@"
	msg -i "Dropping into a rescueshell..."

	$SPLD && spld_stop
	debug rsh || debug $sh -aim
}
source $LIBDIR/functions || die

# @DESCRIPTION: Shell Run Level helper
# @USAGE: <LEVEL>
lvl() {
	msg -i ">>> Switching to init shell run level: $1"
	export LVL=$1

	for _f in $(ls $LIBDIR/${1}-* 2>/dev/null); do
		dohook "$_f"
	done
	[ "$LVL" = "$RSH" ] && debug die
	return 0
}

# @DESCRIPTION: Splash daemon helper
spld() {
	$ECK && for bin in fbcondecor_helper splash_util; do 
		debug -d bck $bin
	done
	local IFS="${IFS}," _opt _opts cachedir event mode theme util
	
	event="$(grep -Hsi keyboard /sys/class/input/input*/name | \
		sed -e 's#.*input\([0-9]*\)/name.*#event\1#')"
:	${cachedir:=/run/splash/cache}
:	${util=$(which splash_util)}
:	${BOOT_MSG:="Booting the system (\$progress%)... Press F2 for verbose mode."}
:	${SPLASH_FIFO=$cachedir/.splash}
	export BOOT_MSG SPLASH_FIFO
	
	for _opt in $splash; do
		case "${_opt%:*}" in
			(fad*) _opts="set effects $_opt"      ;;
			(silent|verbose) mode="$_opt"         ;;
			(tty) export CONSOLE=/dev/"${_opt/:/}";;
			(theme) theme="${_opt#*:}"            ;;
		esac
	done

	[ -d "$cachedir" ] || mkdir -p $cachedir
	debug mkfifo $SPLASH_FIFO
	debug $util -d -ms -t $theme && SPLD=true
	[ -n "$_opts" ] && debug spld_cmd $_opts
	debug spld_cmd "set event dev /dev/input/$event"
	debug spld_cmd "set autoverbose 0"
}

# @DESCRIPTION: Resume helper (support SwSusp/TuxOnIce)
# @USAGE: <[type:]dev[:signature]>
resume() {
	local _asw _dev=$1 _img_sz _hpr
	msg -i "Resuming from hibernation..."
	grep -q $MNTDIR /proc/mounts && debug -d umount -l $MNTDIR

	if [ -d /sys/power/tuxonice ]; then
		if $SPLD; then
			[ -n "$theme" ] &&
			debug ln -sf "/etc/splash/$theme" /etc/splash/tuxonice
			_hpr="$(which tuxoniceui_fbsplash)"
		else
			_hpr="$(which tuxoniceui_text)"
		fi
		$ECK && debug -d bck $_hpr
		echo $_hpr >/sys/power/tuxonice/user_interface/program
		
		debug _modprobe tuxonice
		echo $_dev >/sys/power/tuxonice/resume

		read _img </sys/power/tuxonice/image_exists
		if [ "$_img_sz" = "1" ]; then
			echo >/sys/power/tuxonice/image_exists
		else
			echo >/sys/power/tuxonice/do_resume
		fi
	elif [ -f /sys/power/resume ]; then
		debug _modprobe swsusp
		echo platform >/sys/power/disk # or 'shutdown'  if ACPI does not work
		echo disk >/sys/power/state

		local _node=${_dev#*:}
		[ "${_node/mapper}" = "$_node" ] || _node=$(readlink $_node)
		read _node  </sys/class/block/${_node#*/}/dev
		echo $_node >/sys/power/resume

		read _img_sz </sys/power/image_exists
		if [ "$_img_sz" != "0" ]; then
			echo $_node >/sys/power/resume
		else
			echo 0 >/sys/power/image_size
		fi
	fi
}

# -*- Initialisation -*-

debug -d mkdir -p dev/pts proc run sys $NEWROOT $MNTDIR
debug -d mount -t proc proc /proc

for arg in $(cat /proc/cmdline); do
	case "$arg" in
		([Rr][Ee][Ss][Cc][Uu][Ee]*|[Rr][Ss][Hh]*) export RSH=1;;
		(ienv=*) export "$arg"                      ;;
		(ro|rw)  export mopt="$arg"                 ;;
		(single) export RIL=2                       ;;
		(splash*|console*|CONSOLE*) export "$arg"   ;;
		(ihook=*) export HOOKS="${arg#*=}"          ;;
		(i[bdklmnrsz]*) export "$arg"               ;;
	 esac
done

if [ -n "$irsh" ]; then
	RSH="${irsh%:*}"
	arg "RIL" "$irsh" "2" ":" "-s"
fi

DEBUG="${idebug%:*}"
DMESG="${idebug#*:}"
[ "$DMESG" = "$DEBUG" ] && DMESG=

yesno "${ienv:-YES}"
case $? in
	(1) ENV=false;;
esac
${ENV:-true} && [ -f $CONFDIR/env ] &&
while read _line; do
	case "${_line%%=*}" in
		(CONFDIR|LIBDIR|HOME|KEYMODE|LOGFILE|MNTDIR|NEWROOT|RIL|PATH|RSH|SPLD|sh)
			:;;
		([a-zA-Z]*) [ "${ienv/:${_line%%=*}}" = "$ienv" ] && export "$_line"   ;;
	esac
done < $CONFDIR/env
$ECK && debug ack

[ -n "$DEBUG" ]  && set -${DEBUG/e/}
[ -n "$DMESG" ]  && debug dmesg -n $DMESG
unset DEBUG DMESG

debug -d mount -t sysfs sysfs /sys
debug -d mount -t tmpfs -o mode=755 tmpfs /run
mv -f $LOGFILE /run && export LOGFILE=/run$LOGFILE
debug umask 0077

if grep -q devtmpfs /proc/filesystems; then
	debug -d mount -t devtmpfs devtmpfs /dev
else
	debug -d mount -t tmpfs -o mode=755 tmpfs /dev
fi
debug mkdir /dev/pts
debug mount -t devpts -o gid=5,mode=0620 devpts /dev/pts

echo >/dev/mdev.seq
debug -d mdev -s
echo /sbin/mdev >/proc/sys/kernel/hotplug
	
for _m in $(echo "$imod" | sed 's/:/ /g'); do
	debug _modprobe $_m
done

[ -h /dev/fd     ] || debug ln -fs /proc/self/fd   /dev/fd
[ -h /dev/stderr ] || debug ln -fs /proc/self/fd/2 /dev/stderr
[ -h /dev/stdin  ] || debug ln -fs /proc/self/fd/0 /dev/stdin
[ -h /dev/stdout ] || debug ln -fs /proc/self/fd/1 /dev/stdout

:	${CONSOLE:=${console:-/dev/console}}
[ "${CONSOLE/dev}" != "$CONSOLE" ] || CONSOLE="/dev/$CONSOLE"
[ -c $CONSOLE ] || CONFDIR=/dev/console
exec 0<$CONSOLE 1>$CONSOLE 2>&1
export CONSOLE

[ -f $CONFDIR/boot ] &&
for _m in $(cat $CONFDIR/boot); do
	debug _modprobe $_m
done

[ -n "$splash" ] && debug spld

# -*- Font and keymap -*-

if [ -n "$ikmap" ]; then
	font="${ikmap#*:}"
	kmap="${ikmap%:*}"
	[ "$font" = "$kmap" ] && font=
fi
[ -z "$font" ] && [ -f "$CONFDIR/font" ] && font=$(cat $CONFDIR/font)
[ -z "$kmap" ] && [ -f "$CONFDIR/kmap" ] && kmap=$(cat $CONFDIR/kmap)
FONTDIR=/usr/share/consolefonts
KMAPDIR=/usr/share/keymaps
for file in $FONTDIR/$font*; do
	[ -f "$file" ] && debug loadfont < $file && break
done
for file in $KMAPDIR/$kmap*; do
	[ -f "$file" ] && debug loadkmap < $file && break
done
unset FONTDIR KMAPDIR file font kmap

lvl 1

# -*- Logo and or boot message -*-
[ -f /etc/issue.logo ] && cat /etc/issue.logo
debug test -f /etc/msg && clear &&
while read _line; do
	msg -i "$_line"
done </etc/msg

# -*- Hooks -*-
lvl 2

for hook in bcache \
	btrfs \
	zfs zram; do
	eval test -n \"\$i$hook\"
	[ $? = 0 ] && HOOKS="$hook $HOOKS"
done
export HOOKS="$(echo $HOOKS | sed -e 's/:/ /g')"
for hook in $HOOKS; do
	if [ -e "$LIBDIR/$hook" ]; then
		debug dohook "$LIBDIR/$hook"
	else
		error "hook: $hook not found"
	fi
done

# -*- Swap/Resume -*-
# SWAP should be set if available
if [ -n "$iswap" ]; then
	lvl 2s
	[ -z "$SWAP" ] && debug -d bkd "$iswap" "SWAP" "2" "$ikswap"
fi
# RESU should be set if available
if [ -n "$iresume" ]; then
	if [ -z "$RESU" ] && [ "$iresume" != "swap" ]; then
		debug -d bkd "$iresume" "RESU" "3" "$ikresume"
	fi
	lvl 2r
	debug resume "${RESU:-$SWAP}"
fi

# -*- Root -*-
lvl 3
# ROOT should be set if available
dorootfs() {
	local FS CHK ROOT
	eval set -- $(echo "$iroot" | sed -e 's/:/ /g')
	FS="$2" CHK="$3" ROOT="$1"
	debug -d bkd "$iroot" "ROOT" "1" "$ikroot"

	lvl 3f
	if [ -n "$CHK" ]; then
		yesno $CHK && CHK=-d || CHK=-e
		debug $CHK fsck ${FS:+-t$FS} $ROOT
	fi
	lvl 3m
	if [ -n "$mopt" ]; then
		imopt="${imopt:+$imopt,}$mopt"
		unset mopt
	fi
	debug mount ${imopt:+-o$imopt} ${FS:+-t$FS} $ROOT $NEWROOT ||
		die "Failed to mount rootfs"
}
[ -z "$ROOT" ] && dorootfs
[ -n "$isquashd" ] && lvl 3s && debug -d squashd

# -*- Clean up and switch -*-
lvl 4

[ -n "$LBK" ] &&
for _k in $(echo $LBK | sed '/:/ /g'); do
	debug dmclose "$_k"
done
[ -n "$LBD" ] &&
for _d in $(echo $LBD | sed 's/:/ /g'); do
	debug losetup -d $_d
done

[ "$KEYMODE" = "gpg" ] && debug _rmmod gpg
if grep -q $MNTDIR /proc/mounts; then
	debug -d umount -l $MNTDIR
	debug _rmmod remdev
fi

[ -n "$imount" ] && lvl 4m && debug fmount

lvl 4u
echo >/proc/sys/kernel/hotplug
msg -i "Switching / ..."
$SPLD && debug spld_stop

for _dir in /run /sys /dev /dev/pts /proc; do
	[ -f $LOGFILE ] || export LOGFILE=/$0.log
	if [ "${SYSFS/$_dir}" != "$SYSFS" ]; then
		mkdir -p $NEWROOT$_dir
		debug -d mount -M $_dir $NEWROOT$_dir
	else
		debug -d umount -l $_dir
	fi
done

lvl 4s
debug -d exec switch_root $NEWROOT ${init:-/sbin/init} $RIL

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
