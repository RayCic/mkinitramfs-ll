#!/bin/sh
# $Header: mkinitramfs-ll/init,v 0.9.4 2012/06/30 12:36:57 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.
#
init=/sbin/init # real init to execute after switching to real root
eck=1           # test if env binaries exist in PATH
rmap=root       # root mapping for dmcrypt

info() 	{ echo -ne "\033[1;32m * \033[0m$@\n"; }
error() { echo -ne "\033[1;31m * \033[0m$@\n"; }

debug() {
	local _cmd _opt _ret
	[ "$1" = "-d" ] || [ "$1" = "-e" ] || [ "$1" = "-i" ] && _opt=$1 && shift
	_cmd="$@"; $_cmd; _ret=$?
	echo "[$_ret]: $_cmd" >> $logdir/init.log
	if [ ! "$_ret" ]; then
		case $_opt in
			-d) die "d[$_ret]: $_cmd";;
			-e) error "e[$_ret]: $_cmd";;
			-i) info "i[$_ret]: $_cmd";;
		esac
	fi
	return "$_ret"
}

rsh() {
	export PS1='rsh:$(tty | cut -c6-):$PWD # '
	if [ $spld ]; then
		debug openvt -c${console#*tty} sh -i 0<$console 1>$console 2>&1
	elif ack setsid; then debug setsid sh -i 0<$console 1>$console 2>&1
	else debug sh -i 0<$console 1>$console 2>&1; fi
}

die() {
	local _msg="Dropping into a rescueshell..."
	debug umount -f -l /mnt/tok &>/dev/null
	[ -n "$@" ] && error "$@" && spl_msg "$@"
	info "$_msg"; spl_msg "$_msg"
	for _k in $ldk; do debug dmclose "$_k"; done
	for _d in $ldv; do debug losetup -d "$_d"; done
	debug rsh || debug exec sh -i
}

bck() { debug -d which $1 &>/dev/null; }
ack() {
	local _app _applets="$@"
	[ -n "$_applets" ] || [ -f /etc/mkinitramfs-ll/busybox.app ] &&
		_applets="$(cat /etc/mkinitramfs-ll/busybox.app)" ||
		debug -d busybox --install -s && return
	for _app in $_applets; do 
		[ -h "$_app" ] && [ "$(readlink $_app)" = "/bin/busybox" ] ||
			debug -d busybox --install -s && break
	done
}

_rmmod() {
	if [ -f "/etc/mkinitramfs-ll/module.$1" ]; then
		for _m in $(cat /etc/mkinitramfs-ll/module.$1); do 
			debug rmmod $_m
		done
	fi
}

_modprobe() {
	if [ -f "/etc/mkinitramfs-ll/module.$1" ]; then
		for _m in $(cat /etc/mkinitramfs-ll/module.$1); do 
			debug modprobe $_m
		done
	fi
}

spl_cmd() { debug echo "$@" > $SPLASH_FIFO; }
spl_verbose() { debug chvt ${console#*tty}; debug spl_cmd "set mode verbose"; }
spl_silent() { debug chvt ${console#*tty}; debug spl_cmd "set mode silent"; }
spl_msg() { [ $spld ] && debug spl_cmd "set message $@" && debug spl_cmd "repaint"; }

spld_stop() { [ $spld ] && spld=1; debug spl_cmd "exit"; }
spld_init() {
	[ -n "$(echo "$splash" | grep fadein)" ] && local _opt="-c set effects fadein"
	spl_mode=${splash%%,*} theme:=${splash#*:}
	spl_cachedir=/run/splash/cache
	spl_util=splash_util
	export SPLASH_FIFO=$spl_cachedir/.splash
	[ "$eck" ] && debug bck $spl_uil
	[ -d "$spl_cachedir" ] || mkdir -p $spl_cachedir
	debug mkfifo $SPLASH_FIFO
	debug $spl_util $_opt -d -t "$theme" && spld=0
	debug spl_cmd "set event dev evdev"
	[ "${spl_mode:-verbose}" = "verbose" ] && debug spl_verbose || debug spl_silent
}

shrl() {
	local _msg="Switching to init shell runlevel: $1"
	info "$_msg"; spl_msg "$_msg"
	local _scr="$(ls /etc/local.d/${1}?-*.sh &> /dev/null)"
	if [ -n "$_scr" ]; then
		for _s in $_scr; do 
			info "exec: sh -ex $_s..."
			debug -d sh -ex $_s
		done
	fi
	[ "$shrl" = "$1" ] && debug die
}

_blkid() { eval $2=$(blkid | grep "${1#*=}" | cut -d':' -f1); }

getldk() {
	if [ ! "$cld" ]; then
		local _ld="$(debug -d losetup -f)"
		debug -d losetup "$_ld" "$1"
		ldv="$_ld:$ldv"
	else local _ld="$1"; fi
	debug cryptsetup luksOpen "$_ld" "$_fn" 
	if [ "$?" ]; then
		kfile=/dev/mapper/"$_fn"
		ldk="$_fn:$ldk"
	fi
}

getkey() {
	local _fp="$(echo "$1" | cut -d':' -s -f3)"
	local _kd="$(echo "$1" | cut -d':' -s -f2)"
	local _km="$(echo "$1" | cut -d':' -s -f1)"
	local _dv _fn=${_fp##*/}
	if [ -n "$_km" ]; then 
		if [ "$_km" != "none" ];then
			if [ -z "$cld" ]; then
				local _v=$(cryptsetup --version | awk '{print $2}')
				[ $(echo "$_v" | cut -d'.' -f2) -ge 3 ] && cld=0
				[ $(echo "$_v" | cut -d'.' -f2) -ge 4 ] && cdh=0
				[ "$cdh" ] && [ $(echo "$_v" | cut -d'.' -f3) -ge 2 ] && cid=0
			fi
		else return; fi
	else return; fi
	if [ "$_km" != "pwd" ]; then
		[ -n "$_kd" ] || die "ik$2=$_km:$_kd:$_fp device field empty"
		[ -n "$_fp" ] || die "ik$2=$_km:$_kd:$_fp filepath field empty"
		debug _blkid "$_kd" "_dv"
		if [ -z "$(mount | grep /mnt/tok)" ]; then
			if [ ! -b "$_dv" ]; then
				sleep 2; debug _blkid "$_kd" "_dv"
				if [ ! -b "$_dv" ]; then
					info "Insert removable device and press Enter."
					read; sleep 2; debug _blkid "$_kd" "_dv"
				fi
				while [ ! -b "$_dv" ]; do
					info "$_dv does not exist, input a valid dev name"
					info "e.g. '[/dev/]sdb1', 'LABEL=<label>' 'UUID=<uuid>'"
					read _dv; sleep 2; debug _blkid "$_dv" "_dv"
				done
			fi
			debug -d mount -n -r "$_dv" /mnt/tok
		fi
		debug -d test -f "/mnt/tok/$_fp"
	fi
	case $_km in
		gpg) [ "$eck" ] && bck "gpg"; kfile="/mnt/tok/$_fp"; kmode=gpg;;
		reg) kfile="/mnt/tok/$_fp"; kmode=reg;;
		ldk) [ -e "/dev/mapper/$_fn" ] || getldk "/mnt/tok/$_fp"; kmode=ldk;;
		pwd) kmode=pwd;;
		*)   die "$_km: keymode is invalid";; 
	esac
}

dmclose() { 
	[ -n "$2" ] && debug -d vgchange -an ${2%-*}
	local IFS="${IFS}:" 
	for _p in $1; do 
		debug cryptsetup luksClose ${_p%-*} $header ||
			debug cryptsetup remove ${_p%-*} $header
	done
}

dmcrypt() {
	local _apd _asw _cpr _ksz _use
	info "Type a valid LUKS cipher:hash, default is 'aes-xts-plain:sha256'"
	info "you can take something safer like 'aes-cbc-essiv:sha256'"
	read _cpr
	info "Type a valide key-size [256|512], default is 256 bits:"
	read _ksz
	if [ -e "$kfile" ]; then 
		info "use the existing $kfile keyfile? [NO|yes]"
		read _use
		[ "${_use:-no}" = "yes" ] && _use="-d $_use" || _use=
	fi
	if [ -b "$_hdr" ]; then info "use $_hdr detached header [NO|yes]?"
		read _asw
		if [ "${_asw:-no}" = "yes" ]; then info "Enter a valid aligh-payload offset,"
			info "this option is taken as absolute sector alignment and can be zero"
			read _apd; _apd="--align-payload $_apd"
		else _hdr=; fi
	fi
	debug -d cryptsetup $_arg $_dev -c${_cpr:-aes-xts-plain:sha256} \
		-s${_ksz:-256} $_use $_hdr $_apd
}

dmopen() { 
	[ "$eck" ] && bck "cryptsetup"
	local _arg=luksFormat _asw dev
	local _map=$(echo "$1" | cut -d'-' -f1)
	local _dev=$(echo "${1#*-}" | cut -d'+' -f1)
	local _hdr=$(echo "$1" | cut -d'+' -s -f2)
	if [ "$cid" ] && [ -n "$(echo "$_dev" | grep -i UUID)" ]; then :;
	else debug -d _blkid "$_dev" "_dev"; fi
	if [ -n "$_hdr" ]; then
		if [ -n "$(echo "$_hdr" | grep -E '(UUID|LABEL|sd[a-z][0-9])')" ]; then 
			if [ "$cid" ] && [ -n "$(echo "$_hdr" | grep -i UUID)" ]; then :;
			else debug _blkid "$_hdr" "_hdr"; fi
			debug -d test -b "$_hdr" && header="$_hdr" _hdr="--header $_hdr"
		elif [ -e "/mnt/tok/$_hdr" ]; then header="$_hdr" _hdr="--header /mnt/tok/$_hdr"
		else die "$_hdr detached header doesn't exist."; fi
	fi
	debug cryptsetup isLuks "$_dev" "$header"
	if [ ! "$?" ]; then
 		info "cre[ate] $_dev or dec[rypt] another LUKS PV? [cre|DEC]"
		read _asw
		if [ "${_asw:-dec}" = "dec" ]; then
			while true; do
				info "Type in valid LUKS PV e.g. sda5|UUID=<uuid>|LABEL=<label>"
				read _dev; debug _blkid "$_dev" "_dev"
				debug cryptsetup isLuks "$_dev" "$header" && break
			done
		elif [ "$_asw" = "cre" ]; then debug dmcrypt; fi
	fi
	debug -d test -b "$_dev" && _arg=luksOpen
	if [ "$kmode" = "gpg" ]; then 
		mv /dev/tty /dev/bak && cp -a /dev/console /dev/tty
		for _i in 1 2 3; do
			debug gpg -qd "$kfile" | cryptsetup "$_arg" "$_dev" "$_map" $_hdr && break
			[ $_i -eq 3 ] && error "...there's still a pwd mode fallback..."
		done
		rm /dev/tty && mv /dev/bak /dev/tty
	elif [ "$kmode" = "ldk" ] || [ "$kmode" = "reg" ]; then 
		debug cryptsetup "$_arg" "$_dev" "$_map" -d "$kfile" $_hdr ||
		error "...there's still a pwd mode fallback..."
	fi
	dev=/dev/mapper/$_map
	[ ! -b "$dev" ] || debug -d cryptsetup "$_arg" "$_dev" "$_map" "$_hdr"
	debug -d test -b $dev && eval ${2:-ctxt}=$dev
}

lvopen() {
	[ "$eck" ] && bck "lvm"
	local _lv=${1/-//}
	if debug lvchange -ay $_lv; then :;
	elif [ -n "$2" ]; then
		local _pv="$2" IFS="${IFS}:"
		[ -e "/mnt/tok/$_pv" ] && _pv="$(cat /mnt/tok/$_pv)"
		for _p in $_pv; do debug dmopen "$_p"; done
		debug vgchange -ay ${1%-*} || debug -d dmclose "$_pv" "$1"
	else die "$1 require a valid crypted physical volume"; fi
	if [ -b "/dev/mapper/$1" ]; then eval $3=/dev/mapper/$1
	elif [ -b "/dev/$_lv" ]; then eval $3=/dev/$_lv
	else die "$_lv VG/LV do not exist."; fi
}

mdopen() {
	local _dev=${1%%-*} _prt=$(echo "$1" | cut -d'+' -f2)
	[ -n "$(echo $_dev | grep /dev)" ] || _dev=/dev/$_dev
	[ -b "$_dev" ] && return
	if [ -n "$(echo $1 | grep UUID)" ]; then
		if [ -n "$_prt" ]; then
			echo DEVICE $(ls /dev/sd*$_prt) >> /etc/mdadm.conf
		else echo 'DEVICE /dev/sd??*' >> /etc/mdadm.conf; fi
		echo ARRAY $_dev $(echo "${1#*-}" | cut -d'+' -f1) >> /etc/mdadm.conf
	fi
	debug mdadm --assemble --scan "$_dev" || raidautorun
	debug -d test -b "$_dev"
}

squashd() {
	local IFS="${IFS}:"
	debug -d test -n $sqfsd
	debug -d test -d /newroot$sqfsdir
	debug _modprobe sqfsd
	cd /newroot
	for _dir in $sqfsd; do
		local _bdir="$sqfsdir"/$_dir
		debug -d test -f .$_bdir.sfs
		debug mkdir -p .$_bdir/rw .$_bdir/ro
		debug -d mount -tsquashfs -onodev,loop,ro .$_bdir.sfs .$_bdir/ro &&
		mount -taufs -onodev,udba=reval,br:.$_bdir/rw:.$_bdir/ro $_dir $_dir
	done
}
rootfs() {
	[ -n "$iroot" ] || die "iroot=<PV|VG-LV>[:<c>:<fs>] argument is missing"
	local _fscf _dev=${iroot%%:*}
	local _fsck="$(echo "$iroot" | cut -d':' -f2)"
	local _fs="$(echo "$iroot" | cut -d':' -f3)"
:	local ${_lvm:=$(echo "$ilvm" | cut -d',' -f1)}
:	local ${_raid:=$(echo "$iraid" | cut -d',' -f1)}
	debug -d getkey "$ikroot" "root"
	shrl 3d
	[ -n "$_raid" ] && mdopen "$_raid"
	if [ -n "$_lvm" ]; then debug -d lvopen "$_dev" "$_lvm" "_dev"
	elif [ -n "$kmode" ]; then debug -d dmopen "${rmap:-root}-$iroot" "_dev"
	else debug -d _blkid "$_dev" "_dev"; fi
	shrl 3f
	if [ -n "$_fsck" ]; then 
		[ "$_fsck" = "n" ] || [ "$_fsck" = "no" ] && _fscf="-e" || _fscf="-d"
		debug $_fscf fsck ${_fs:+-t$_fs} $_dev 
	fi
	shrl 3m
	debug mount ${imopt:+-o$imopt} ${_fs:+-t$_fs} $_dev /newroot
	if [ ! "$?" ]; then
		if [ -n "$kmode" ]; then
			debug -d dmclose "${_lvm:-${rmap:-root}}" "${_lvm:+${_dev##*/}}"
		fi
		die "failed to mount rootfs"
	fi
	shrl 3s
	[ -n "$sqfsd" ] && debug -d squashd
	imopt=; iroot=; ikroot=; kmode=; sqfsdir=; sqfsd=
}

swap() {
	[ -n "$2" ] || die "i$1=<type>:<PV|VG-LV>[:<sign>] argument is missing"
	local _swp="$3"  _type="${1%%:*}"
	local _dev="$(echo "$1" | cut -d':' -s -f2)" 
	local _sign="$(echo "$1" | cut -d':' -s -f3)"
	debug -d getkey "$2" "$_swp"
	[ -n "$_raid" ] && debug -d mdopen "$_raid"
	if [ -n "$_lvm" ]; then debug -d lvopen "$_hdev" "$_lvm" "_dev"
	elif [ -n "$kmode" ]; then debug -d dmopen "$_swp-$_dev" "_dev"
	else debug -d _blkid "$_dev" "_dev"; fi
	[ -n "$4" ] && eval $4=$_type:$_dev${_sign+:$_sign}
	eval i$1= ik$1=; kmode=
}

resume() {
	local _asw _dev _img _msg _toi _spd
	_msg="Resuming from hibernation..."
	info "$_msg"; spl_msg "$_msg"
	if [ -n "$(echo "$iresume" | cut -d':' -s -f2)" ]; then
:		local ${_raid:=$(echo "$iraid" | cut -d',' -f3)}
:		local ${_lvm:=$(echo "$ilvm" | cut -d',' -f3)}
		debug -d swap "$iresume" "$ikresume" "resume" "_dev"
	fi
	debug -d mount -n -o remount,ro /newroot
	if [ -d /sys/power/tuxonice ]; then
		_toi="$(which tuxoniceui_text)"
:		${_toi:=$(which tuxoniceui_fbsplash)}
		debug _modprobe tuxonice
		debug -d echo $_dev > /sys/power/tuxonice/resume
		_i="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "toi: no recognizable signature at the pointed location"
			error "toi: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "toi: resume aborted"
		else die "toi: no image found at the pointed location"; fi
		if [ -n "$theme" ]; then
			ln -sf "/etc/splash/$theme" /etc/splash/tuxonice
		fi
		spld_stop
		echo $_toi > /sys/power/tuxonice/user_interface/program
		debug -d echo > /sys/power/tuxonice/do_resume
		debug -d echo > /sys/power/tuxonice/image_exists
		debug _rmmod tuxonice
	elif [ -f /sys/power/resume ]; then
		_spd="$(which suspendui_text)"
:		${_spd:=$(which suspendui_fbsplash)}
		debug _modprobe swsusp
		debug -d echo $_dev > /sys/power/disk/resume
		_img="$(cat /sys/power/image_exists | head -n 1)"
		if [ "$_img" = "1" ]; then 
			error "suspend: no recognizable signature at the pointed location"
			error "suspend: proceed anyway [NO|yes]? "
			read _asw
			[ "${_asw:-no}" != "yes" ] && die "suspend: resume aborted"
		else die "suspend: no image found at the pointed location"; fi
		spld_stop
		debug -d echo disk > /sys/power/state
		debug _rmmod swsusp
	else error "no suspend/hibernation support found"; fi
	debug -d mount -n -o remount,rw /newroot
	die "failed to resume from hibernation"
}

imount() {
	local _fs _dev _mpt _opt _x _y _z IFS="${IFS}:"
	for _x in $imount; do
		_y="$(grep $_x /newroot/etc/fstab)"
		if [ -n "${y}" ]; then
			 _fs=$(echo "$_y" | awk '{print $3}')
			_dev=$(echo "$_y" | awk '{print $1}')
			_mpt=$(echo "$_y" | awk '{print $2}')
			_opt=$(echo "$_y" | awk '{print $4}')
		else
			error "$_x not found in fstab"
			break
		fi
		for _z in 0 1 2 3 4; do
			[ "$_opt" = "$_z" ] && _opt=
		done
		debug -d test -b $_dev
		debug -d test -d $_mpt
		debug -d mount -t$_fs ${_opt:+-o$_opt} $_dev /newroot/$_mpt
	done
}

switch() {
	echo > /proc/sys/kernel/hotplug
	local _msg="Switching / ..."
	info "$_msg"; spl_msg "$_msg"
	debug spld_stop
	sleep 1
	shrl 4u
	debug -d umount -l /proc
	debug -d umount -l /sys
	debug -d umount -l /dev
	debug -e umount -l /run
	shrl 4s
	debug -d exec switch_root /newroot ${init:-/sbin/init} $rirl
}

main() {
	debug _init
	local _font=$(echo "$ikmap" | cut -d':' -f2)
	local _kmap=$(echo "$ikmap" | cut -d':' -f1)
	if [ -n "$_kmap" ]; then
		for _dir in /usr/share/keymaps /etc /; do
			if [ -f "$_dir/$_kmap" ]; then
				debug -d loadkmap < "$_dir/$_kmap" && break
			fi
		done
	fi
	if [ -n "$_font" ]; then
		for _dir in /usr/share/consolefonts /etc /; do
			if [ -f "$_dir/$_font" ]; then
				debug -e loadfont < "$_dir/$_font" && break
			fi
		done
	fi
	debug test -f /etc/msg && clear && while read _line; do
		info "$_line"; spl_msg "$_line"
	done < /etc/msg
	debug _modprobe gpg
	debug _modprobe remdev
	shrl 1
	if [ -n "$iswap" ]; then
:		local ${_raid:=$(echo "$iraid" | cut -d',' -f2)}
:		local ${_lvm:=$(echo "$ilvm" | cut -d',' -f2)}
		shrl 2s
		swap "$iswap" "$ikswap" "swap"
	fi
	[ -n "$iresume" ] && shrl 2r && debug resume
	debug rootfs
	shrl 4c
	local IFS="${IFS}:"
	for _k in $ldk; do debug dmclose "$_k"; done
	for _d in $ldv; do debug losetup -d $_d; done
	debug _rmmod gpg
	debug -e umount -f -l /mnt/tok
	debug _rmmod remdev
	[ -n "$imount" ] && shrl 4m && debug imount
	debug switch
}

_getopts() {
	for arg in $(cat /proc/cmdline); do
    		case $arg in
			rescue*)  shrl=1;;
			single)   rirl=2;;
			isqfsd=*) export $arg
				if [ "${isqfsd%,*}" = "y" ]; then sqfsdir=${sqfsdir:-/sqfsd}
				else sqfsdir=${isqfsd%,*}; fi
				if [ "${isqfsd#*,}" = "y" ]; then sqfsd=${sqfsd:-usr:opt:bin:sbin}
				elif [ "$(echo ${isqfsd#*,}|cut -d':' -f1)" = "a" ]; then
					sqfsd=${sqfsd:-usr:opt:bin:sbin}:$(echo ${isqfsd#*,} | cut -c3-)
				else sqfsd=$(echo ${isqfsd#*,} | cut -c3-); fi;;
			*init=*)  export init=${arg#*=};;
			ishrl=*)  shrl=$(echo ${arg#*=}|cut -d':' -f1)
				      rirl=$(echo ${arg#*=}|cut -d':' -f2);;
			dmesg|ikmap*|ilvm*|imo*|*root*|*resume*|*swap*|splash*) export $arg;;
	   	 esac
	done
}

_init() {
	debug export PATH=/sbin:/bin:/usr/bin:/usr/sbin HOME=/root
	debug umask 0077
	debug -d mkdir -p dev proc run sys newroot mnt/tok
	debug -d mount -t proc proc /proc
	debug -d mount -t tmpfs -o mode=755 tmpfs /run
	debug -d mkdir -p /run/log && logdir=/run/log
	debug mv -f /init.log $logdir
	[ "$eck" ] && debug ack
	debug -d mount -t sysfs sysfs /sys
	debug _getopts
	[ -n "$dmesg" ] && debug dmesg -n $dmesg
	debug _modprobe boot
	if grep devtmpfs /proc/filesystems &>/dev/null; then
		debug -d mount -t devtmpfs devtmpfs /dev
	else debug -d mount -t tmpfs tmpfs /dev; fi
	debug -d mdev -s
	debug -d 'echo /sbin/mdev > /proc/sys/kernel/hotplug'
	if [ -n "$mod" ]; then local IFS="${IFS},"
		for _m in $mod; do 
			debug modprobe $_m
		done
	fi
	[ -h /dev/fd     ] || debug ln -fs /proc/self/fd   /dev/fd
	[ -n /dev/stderr ] || debug ln -fs /proc/self/fd/2 /dev/stderr
	[ -n /dev/stdin  ] || debug ln -fs /proc/self/fd/0 /dev/stdin
	[ -n /dev/stdout ] || debug ln -fs /proc/self/fd/1 /dev/stdout
:	${console:=/dev/tty1}
	[ -n "$(echo $console | grep /dev)" ] || console="/dev/$tty"
	exec 0<$console 1>$console 2>&1
	[ -n "$splash" ] && debug spld_init
}
main

# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
