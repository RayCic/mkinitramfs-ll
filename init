#!/bin/sh
# $Header: mkinitramfs-ll/init,v 0.6.0 2012/05/17 10:23:04 -tclover Exp $
#
# WARNING: USE AT YOUR OWN RISK!
# NEED SOME HELP? WHERE'S THE README FILE? YOU ASK? WHO KNOWS.
#
# user defined variables
uv_init=/sbin/init      # init to execute after switching to real root
uv_root_map=root        # self descriptive
uv_check_env=0          # test if busybox/applets and the other binaries exist 
uv_sqfsdir=/sqfsd       # squashed source dir related variable
uv_sqfsd=usr:bin:sbin:lib32:lib64 # squashed dirs variable
# default values [edit at your own risk]
gv_splashd=1
gv_splash=verbose
gv_shrl=0
# functions
info() 	{ echo -ne "\033[1;32m * \033[0m$@\n"; }
error() { echo -ne "\033[1;31m * \033[0m$@\n"; }

debug() {
	local lvd="${@:0:2}"
	local lvc="${@:3:${#@}}"
	if [ "$lvd" == "-d" ] || [ "$lvd" == "-e" ] || [ "$lvd" == "-i" ]; then $lvc
	else lvc=; $@; fi
	ret=$?
	echo "[${ret}]: ${lvc:-$@}" >> /init.log
	if [ ! "${ret}" ]; then
		case ${lvd} in
			-d) die "d[${ret}]: ${lvc}";;
			-e) error "e[${ret}]: ${lvc}";;
			-i) info "i[${ret}]: ${lvc}";;
		esac
	fi
	return "${ret}"
}

die() {
	umount -ln /mnt/tok
	[ "${gv_splash}" == "silent" ] || verbose
	error "$@"
	info "dropping you into a rescueshell..."
	for lk in ${gv_lkey}; do dmclose "${lk}"; done
	for ld in ${gv_ldev}; do losetup -d ${ld}; done
	exec sh
}

bchk() {
	for dir in /bin /sbin /usr/bin /usr/sbin; do
		[ -f "${dir}/${1}" ] && return
	done
}

achk() {
	if [ -e "/etc/applets" ]; then	
		for app in $(cat /etc/applets); do 
			[ -h ${app} ] || busybox --install -s && break
		done
	else debug -i busybox --install -s; fi
}

_rmmod() {
	if [ -f "/etc/modules/${1}" ]; then
		for mod in $(cat /etc/modules/${1}); do 
			debug rmmod ${mod}
		done
	fi
}

_modprobe() {
	if [ -f "/etc/modules/${1}" ]; then
		for mod in $(cat /etc/modules/${1}); do 
			debug modprobe ${mod}
		done
	fi
}

scmd() { [ "${gv_splashd}" ] && echo "$@" >/lib/splash/cache/.splash; }
verbose() { scmd "set mode verbose"; }
silent() { scmd "set mode silent"; }
smsg() { scmd "set message $@"; scmd "repaint"; }

spalshd_init() {
	[ "${uv_check_env}" ] || bchk "splash_util" "--"
	[ -n "$(echo ${gv_stty} | grep /dev)" ] || gv_stty="/dev/${gv_stty}"
	[ -n "${gv_stty}" ] && exec < ${gv_stty} > ${gv_stty} &>/dev/null
	[ -e /lib/splash/cache ] || mkdir -p /lib/splash/cache
	[ -e /lib/splash/cache/.splash ] || mknod /lib/splash/cache/.splash p
	splash_util --daemon "--theme=${gv_splash_theme}"
	gv_splashd=0
}

splashd_stop() { [ "${gv_splashd}" ] && gv_splashd=1 scmd "exit"; }

ishrl() {
	info "init shell runlevel: ${1}"
	local lv_scr="$(ls /etc/local.d/${1}?-*.sh &>/dev/null)"
	if [ -n "${lv_scr}" ]; then
		for scr in ${lv_scr}; do 
			info "executing ${scr}..."
			debug ${scr} || debug -e "${scr} failed"
		done
	fi
	if [ "${gv_shrl}" == "${1}" ]; then verbose
		info "${1}: dropping into a rescueshell"
		exec sh
	fi
}

_blkid() { echo $(blkid | grep "${1#*=}" | cut -d':' -f1); }

getldkey() {
	local lv_fname="${1##*/}"
	if [ ! "${gv_crypt_loop}" ]; then
		local lv_ldev="$(debug -d losetup -f)"
		debug -d losetup ${lv_ldev} ${1}
		gv_ldev="${lv_ldev}:${gv_ldev}"
	fi
	debug cryptsetup luksOpen "${lv_ldev}" "${lv_fname}" 
	if [ "$?" ]; then
		gv_kfile=/dev/mapper/"${lv_fname}"
		gv_lkey="${lv_fname}:${gv_lkey}"
	fi
}

getkey() {
	local lv_kmode="${1}"
	if [ -n "${lv_kmode}" ]; then 
		if [ "${lv_kmode}" != "none" ];then
			if [ -z "${gv_crypt_loop}" ]; then
				local lv_version=$(cryptsetup --version | awk '{ print $2 }')
				[ $(echo "${lv_version}" | cut -d'.' -f2) -ge 3 ] && gv_crypt_loop=0
				[ $(echo "${lv_version}" | cut -d'.' -f2) -ge 4 ] && gv_crypt_header=0
			fi
		else return; fi
	else return; fi
	if [ "${lv_kmode}" != "pwd" ]; then
		[ -n "${2}" ] || die "ik${4}=${1}:${2}:${3} device field empty."
		[ -n "${3}" ] || die "ik${4}=${1}:${2}:${3} filepath field empty."
		local lv_dev=$(debug _blkid "${2}"); gv_fpath="${3}"
		if [ -z "$(mount | grep /mnt/tok)" ]; then
			if [ ! -b "${lv_dev}" ]; then
				sleep 2; lv_dev=$(debug _blkid "${2}")
				if [ ! -b "${lv_dev}" ]; then
					info "Insert removable device and press Enter."
					read; sleep 2; lv_dev=$(debug _blkid "${2}")
				fi
				while [ ! -b "${lv_dev}" ]; do
					info "${lv_dev} does not exist, input a valid dev name"
					info "e.g. '[/dev/]sdb1', 'LABEL=<label>' 'UUID=<uuid>'"
					read lv_dev; sleep 2; lv_dev=$(debug _blkid "${lv_dev}")
				done
			fi
			debug -d mount -n -r "${lv_dev}" /mnt/tok
			info "Removable device mounted."
		fi
		[ -f "/mnt/tok/${gv_fpath}" ] || \
			die "${gv_fpath} keyfile does not exist in ${lv_dev} remdev."
	fi
	case ${lv_kmode} in
		gpg) [ ${uv_check_env} ] || bchk "gpg" "--"
			 gv_kfile="/mnt/tok/${gv_fpath}"; gv_cmode=gpg;;
		reg) gv_kfile="/mnt/tok/${gv_fpath}"; gv_cmode=reg;;
		ldk) [ -e "/dev/mapper/${gv_fname}" ] || \
			 getldkey "/mnt/tok/${gv_fpath}"; gv_cmode=ldk;;
		pwd) gv_cmode=pwd;;
		*)   die "${lv_kmode}:mode is not valid.";; 
	esac
}

dmclose() { 
	[ -n "${2}" ] && debug -d vgchange -an ${2%-*}
	local IFS="${IFS}:" 
	for pv in ${1}; do 
		debug cryptsetup luksClose ${1%%-*} || debug cryptsetup remove ${1%%-*}
	done
}

dmcrypt() {
	info "Type a valid LUKS cipher:hash, default is 'aes-xts-plain:sha256'"
	info "you can take something safer like 'aes-cbc-essiv:sha256'"
	read local lv_cph
	info "Type a valide key-size [256|512], default is 256 bits:"
	read local lv_ksz
	if [ -e "${gv_kfile}" ]; then 
		info "Do you want to use the existing ${gv_kfile} key-file? [NO|yes]"
		read local lv_ukf
		[ "${lv_ukf:-no}" = "yes" ] && lv_ukf="-d ${lv_ukf}" || lv_ukf=
	fi
	if [ -n "${lv_header}" ]; then info "Do you want to use ${lv_header} [NO|yes]?"
		lv_asw=; read lv_asw
		if [ "${lv_asw:-no}" = "yes" ]; then info "Enter a valid aligh-payload offset,"
			info "option is taken as absolute sector alignment and can be zero"
			read local lv_alp
			[ -n "${lv_alp}" ] && lv_alp="--align-payload ${lv_alp}"
		else lv_header=; lv_alp=; fi
	fi
	debug -d cryptsetup ${lv_arg} ${lv_dev} -c${lv_cph:-aes-xts-plain:sha256} \
		-s${lv_ksz:-256} ${lv_ukf} ${lv_header} ${lv_alp}
}

dmopen() { 
	local lv_arg=luksFormat
	local lv_map=$(echo "${1}" | cut -d'-' -f1)
	local lv_dev=$(echo "${1#*-}" | cut -d'+' -f1); lv_dev=$(_blkid "${lv_dev}")
	local lv_header=$(echo "${1}" | cut -d'+' -s -f2)
	if [ -n "${lv_header}" ]; then
		if [ -n "$(echo "${lv_header}" | grep -E '(UUID|LABEL|sd[a-z][0-9])')" ]; then 
			lv_header=$(_blkid "${lv_header}")
			[ -b "${lv_header}" ] && lv_header="--header ${lv_header}" || \
			die "$lv_header block device doesn't exist."
		elif [ -e "/mnt/tok/${lv_header}" ]; then 
			lv_header="--header /mnt/tok/${lv_header}"
		else die "${lv_header} detached header doesn't exist."; fi
	fi
	debug cryptsetup isLuks "${lv_dev}"
	if [ ! "$?" ]; then
 		info "cre[ate] ${lv_dev} or dec[rypt] another LUKS PV? [cre|DEC]"
		read local lv_asw 
		if [ "${lv_asw:-dec}" == "dec" ]; then 
			while true; do
				info "Type in valid LUKS PV e.g. sda5|UUID=<uuid>|LABEL=<label>"
				read lv_dev; lv_dev=$(_blkid "${lv_dev}")
				debug cryptsetup isLuks "${lv_dev}" && break
			done
		elif [ "${lv_asw}" == "cre" ]; then debug dmcrypt; fi
	fi
	[ -b "${lv_dev}" ] || die "${lv_dev} block device doesn't exist."
	debug -d cryptsetup isLuks "${lv_dev}"
	lv_arg=luksOpen
	if [ "${gv_cmode}" == "gpg" ]; then 
		mv /dev/tty /dev/tty.bak; cp -a /dev/console /dev/tty
		for i in 1 2 3; do
			debug gpg -qd "${gv_kfile}" | cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" \
				${lv_header} && break
			[ ${i} -eq 3 ] && error "...there's still a fallback..."
		done
		rm /dev/tty && mv /dev/tty.bak /dev/tty
	elif [ "${gv_cmode}" == "ldk" ] || [ "${gv_cmode}" == "reg" ]; then 
		debug cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" -d "${gv_kfile}" \
		${lv_header} || error "...there's still a fallback..."
	fi
	if [ ! -b "/dev/mapper/${lv_map}" ]; then
		debug -d cryptsetup "${lv_arg}" "${lv_dev}" "${lv_map}" "${lv_header}"
	fi
}

lvopen() {
	[ "${uv_check_env}" ] || bchk "lvm" "--"
	if debug lvchange -ay ${1/-//}; then continue
	elif [ -n "${2}" ]; then
		local lv_pv="${2}" IFS="${IFS}:"
		[ -e "/mnt/tok/${lv_pv}" ] && lv_pv="$(cat /mnt/tok/${lv_pv})"
		for pv in ${lv_pv}; do debug dmopen "${pv}"; done
		debug vgchange -ay ${1%-*} || debug -d dmclose "${lv_pv}" "${1}"
	else die "${1} require a valid crypted physical volume"; fi
	if [ -b "/dev/mapper/${1}" ]; then eval ${3}=/dev/mapper/${1}
	elif [ -b "/dev/${1/-//}" ]; then eval ${3}=/dev/${1/-//}
	else die "${1/-//} VG/LV do not exist."; fi
}

mdopen() {
	local lv_dev=${1%%-*} lv_part=$(echo ${1} | cut -d'-' -f3)
	[ -n "$(echo ${lv_dev} | grep /dev)" ] || lv_dev=/dev/${lv_dev}
	[ -b ${lv_dev} ] && return
	if [ -n "$(echo ${1} | grep UUID)" ]; then
		if [ -n "${lv_part}" ]; then
			echo DEVICE $(ls /dev/sd*${lv_part}) >> /etc/mdadm.conf
		else echo 'DEVICE /dev/sd??*' >> /etc/mdadm.conf; fi
		echo ARRAY ${lv_dev} $(echo ${1} | cut -d'-' -f2) >> /etc/mdadm.conf
	fi
	debug mdadm --assemble --scan ${lv_dev} || raidautorun
	[ -b ${lv_dev} ] || die "failed to activate ${lv_dev} RAID array."
}

squashd() {
	[ -n "$sqfsdir" ] || die "uv_sqfsdir wasn't set and sqfsdir is empty."
	[ -n "$sqfsd" ]   || die "uv_sqfsd wasn't set and sqfsd is empty."
	[ -d /newroot/"$sqfsdir" ] || die "sqfsdir=$sqfsdir dir doesn't exist."
	debug _modprobe sqfsd
	cd /newroot
	local IFS="${IFS}:"
	for dir in $sqfsd; do
		[ -e ."$sqfsdir/$dir".sfs ] || die "$dir.sfs image doesn't exist."
		mkdir -p ."$sqfsdir/$dir"/rw && mkdir -p ."$sqfsdir/$dir"/ro
		debug -d mount -t squashfs .${sqfsdir}/${dir}.sfs \
			.${sqfsdir}/${dir}/ro -o nodev,loop,ro
		debug -d mount -t aufs ${dir} ${dir} \
			-o nodev,udba=reval,br:.${sqfsdir}/${dir}/rw:.${sqfsdir}/${dir}/ro
	done
}
rootfs() {
	local lv_root=${gv_root%%:*}
	local lv_kmod=${gv_kroot%%:*}
	local lv_kdev="$(echo "${gv_kroot}" | cut -d':' -f2)"
	local lv_kfpt="$(echo "${gv_kroot}" | cut -d':' -f3)"
	local lv_fsck="$(echo "${gv_root}" | cut -d':' -f2)"
	local lv_fs="$(echo "${gv_root}" | cut -d':' -f3)"
:	local ${lv_lvm:=$(echo "${gv_lvm}" | cut -d',' -f1)}
:	local ${lv_raid:=$(echo "${gv_raid}" | cut -d',' -f1)}
	[ -n "${gv_root}" ] || die "iroot=[PV|VG-LV][:<fs>] argument is missing"
	debug getkey "${lv_kmod}" "${lv_kdev}" "${lv_kfpt}" "root"
	ishrl 3d
	[ -n "${lv_raid}" ] && mdopen "${lv_raid}"
	if [ -n "${lv_lvm}" ]; then 
		debug -d lvopen "${lv_root}" "${lv_lvm}" "gv_dev"
	elif [ -n "${gv_cmode}" ]; then
		debug -d dmopen "${uv_root_map:-root}-${gv_root}" 
		gv_dev=/dev/mapper/${uv_root_map:-root}
	else gv_dev=$(debug -d _blkid "${lv_root}"); fi
	ishrl 3f
	[ -n "${lv_fsck}" ] && debug -d fsck ${lv_fs:+-t${lv_fs}} ${gv_dev} 
	ishrl 3m
	debug mount ${gv_mopt:+-o${gv_mtopt}} ${lv_fs:+-t${lv_fs}} ${gv_dev} /newroot
	if [ ! "$?" ]; then
		if [ -n "${gv_cmode}" ]; then
			debug -d dmclose "${lv_lvm:-${uv_root_map:-root}}" "${lv_lvm:+${lv_root}}"
		fi
		die "failed to mount rootfs"
	fi
	ishrl 3s
	[ -n "${sqfsd}" ] && debug squashd
	lv_lvm=; gv_mtopt=; gv_cmode=; gv_dev=
}

swp() {
	local lv_hdev="$(echo "$2"|cut -d':' -s -f2)" 
	local lv_type=${2%%:*}
	local lv_sign="$(echo "$2"|cut -d':' -s -f3)"
	local lv_kmod=${3%%:*}
	local lv_kdev="$(echo "$3"|cut -d':' -s -f2)"
	local lv_kfpt="$(echo "$3"|cut -d':' -s -f3)"
	local lv_mapp=${1}
	[ -n "$lv_hdev" ] || die "${lv_mapp} [PV|VG-LV] is missing"
	[ -n "$lv_type" ] || die "${lv_mapp} type [file|swap] is missing"
	debug getkey "${lv_kmod}" "${lv_kdev}" "${lv_kfpt}" "${1}"
	[ -n "${lv_raid}" ] && debug -d mdopen "${lv_raid}"
	if [ -n "${lv_lvm}" ]; then 
		debug -d lvopen "${lv_hdev}" "${lv_lvm}" "gv_dev"
		gv_dev=${lv_type}:${gv_dev}${lv_sign:+:${lv_sign}}
	elif [ -n "${gv_cmode}" ]; then
		debug -d dmopen "${lv_mapp}-${lv_hdev}"
		gv_dev=${lv_type}:/dev/mapper/${lv_mapp}${lv_sign:+:${lv_sign}}
	else gv_dev=${lv_type}:$(debug -d _blkid "${lv_hdev}")${lv_sign:+:${lv_sign}}; fi
	lv_lvm=; lv_raid=; gv_cmode=; gv_dev=
}

resume() {
	[ "${gv_splash}" == "silent" ] || smsg "Resuming..."
	debug splashd_stop
	if [ -n "$(echo "${gv_toi}" | cut -d':' -s -f2)" ]; then
:		local ${lv_raid:=$(echo "${gv_raid}" | cut -d',' -f3)}
:		local ${lv_lvm:=$(echo "${gv_lvm}" | cut -d',' -f3)}
		debug swp "resume"  "${gv_toi}" "${gv_kresume}"
	fi
	debug _modprobe tuxonice
	debug -d echo ${gv_dev} > /sys/power/tuxonice/resume
	local lv_img="$(cat /sys/power/tuxonice/image_exists | head -n 1)"
	if [ ${lv_img} == 1 ]; then 
		error "There is no recognizable signature at location pointed by iresume|iswap"
		error "Do you want to proceed [NO|yes]? "
		read local lv_asw
		[ "${lv_asw:-no}" != "yes" ] && die "Resume aborted by user"
	elif [ ${lv_img} = 0 ]; then 
		die "No image exist at location pointed by iresume|iswap"; fi
	[ -n "${gv_splash_theme}" ] && ln -sf "/etc/splash/${gv_splash_theme}" \
		/etc/splash/tuxonice
	[ -n "$(which tuxoniceui_text)" ] && echo $(which tuxoniceui_text) > \
		/sys/power/tuxonice/user_interface/program
	[ -z "$(cat /sys/power/tuxonice/user_interface/program)" ] && \
		echo $(which tuxoniceui_fbsplash) >/sys/power/tuxonice/user_interface/program
	debug -d mount -n -o remount,ro
	info "RESUMING from hibernation S[4-5]."
	debug -d echo > /sys/power/tuxonice/do_resume
	debug -d mount -n -o remount,rw /
	debug -d echo > /sys/power/tuxonice/image_exists
	debug _rmmod tuxonice
	die "Resume from hibernation failed, image destroied."
}

switch() {
	echo > /proc/sys/kernel/hotplug
	[ "${gv_splash}" == "silent" ] && silent && smsg "Switching / ..."
	info "SWITCHING root '/'..."
	debug splashd_stop
	sleep 1
	ishrl 4u
	debug -d umount -l /proc
	debug -d umount -l /sys
	debug -d umount -l /dev
	ishrl 4s
	debug -d exec switch_root /newroot ${uv_init:-/sbin/init} ${gv_inrl}
}

imsg() { [ -e /etc/msg ] && info "$(cat /etc/msg)"; }

main() {
	[ "${gv_splash}" == "verbose" ] && verbose
	if [ -n "${gv_kmap}" ]; then
		for dir in /usr/share/keymaps /etc /; do
			if [ -f "${dir}/${gv_kmap}" ]; then
				debug -d loadkmap < "${dir}/${gv_kmap}" && break
			fi
		done
	fi
	if [ -n "${gv_font}" ]; then
		for dir in /usr/share/consolefonts /etc /; do
			if [ -f "${dir}/${gv_font}" ]; then
				debug -d loadfont < "${dir}/${gv_font}" && break
			fi
		done
	fi
	debug imsg
	ishrl 1
	debug _modprobe gpg
	debug _modprobe remdev
	if [ -n "${gv_swap}" ]; then
:		local ${lv_raid:=$(echo "${gv_raid}" | cut -d',' -f2)}
:		local ${lv_lvm:=$(echo "${gv_lvm}" | cut -d',' -f2)}
		ishrl 2s
		swp "swap" "${gv_swap}" "${gv_kswap}"
	fi
	[ -n "${gv_toi}" ] && ishrl 2r && resume
	debug rootfs
	ishrl 4c
	local IFS="${IFS}:"
	for lk in ${gv_lkey}; do dmclose "${lk}"; done
	for ld in ${gv_ldev}; do losetup -d ${ld}; done
	debug _rmmod gpg
	debug -d umount -n -l /mnt/tok
	ebug _rmmod remdev
	debug switch
}

_getopts() {
	local dir
	for arg in $(cat /proc/cmdline); do
    		case $arg in
			rescue*)    gv_shrl=1;;
			single)     gv_inrl=2;;
			isqfsd=*)   dir=${arg#*=}
				if [ "${dir%,*}" = "y" ]; then sqfsdir=${uv_sqfsdir:-/sqfsd}
				else sqfsdir=${dir%,*}; fi
				if [ "${dir#*,}" = "y" ]; then sqfsd=${uv_sqfsd:-usr:opt:bin:sbin}
				elif [ "$(echo ${dir#*,}|cut -d':' -f1)" = "a" ]; then
					sqfsd=${uv_sqfsd:-usr:opt:bin:sbin}:$(echo ${dir#*,} | cut -c3-)
				else 	sqfsd=$(echo ${dir#*,} | cut -c3-); fi;;
			iroot=*)    gv_root=${arg#*=};;
			iraid=*)    gv_raid=${arg#*=};;
			*init=*)    uv_init=${arg#*=};;
			ilvm=*)     gv_lvm=${arg#*=};;
			imod=*)     gv_mod=${arg#*=};;
			imtopt=*)   gv_mtopt=${arg#*=};;
			splash=*)   dir=${arg#*=}
				    gv_splash_theme=${dir#*:}
				    gv_splash=${dir%,*};;
			console=*)  gv_stty=${arg#*=};;
			iresume=*)  gv_toi=${arg#*=};;
			ikmap=*)    gv_kmap=$(echo ${arg#*=}|cut -d':' -f1)
				        gv_font=$(echo ${arg#*=}|cut -d':' -f2);;
			ishrl=*)    gv_shrl=$(echo ${arg#*=}|cut -d':' -f1)
				        gv_inrl=$(echo ${arg#*=}|cut -d':' -f2);;
			iswap=*)    gv_swap=${arg#*=};;
			ikroot=*)   gv_kroot=${arg#*=};;
			ikswap=*)   gv_kswap=${arg#*=};;
			ikresume=*) gv_kresume=${arg#*=};;
	   	 esac
	done
}

_init() {
	export PATH=/sbin:/bin:/usr/bin:/usr/sbin
#	dmesg -n 1
	umask 0077
	for dir in dev proc sys newroot mnt/tok; do mkdir -p /$dir; done
	debug -d mount -t proc proc /proc
#	busybox --install -s
	[ "${uv_check_env}" ] || achk
	[ "${uv_check_env}" ] || bchk "cryptsetup" "--"
	debug -d mount -t sysfs sysfs /sys
	debug _getopts
	debug _modprobe boot
	debug -d mount -t tmpfs tmpfs /dev
	debug -d mdev -s
	debug -d echo /sbin/mdev > /proc/sys/kernel/hotplug
	if [ -n "${gv_mod}" ]; then local IFS="${IFS},"
		for module in ${gv_mod}; do 
			debug modprobe ${module}
		done
	fi
	debug main
}
debug _init

# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
