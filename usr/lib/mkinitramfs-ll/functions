#
# $Header: /lib/mkinitramfs-ll/functions                 Exp $
# $Author: (c) 2011-2015 -tclover <tokiclover@gmail.com> Exp $
# $License: 2-clause/new/simplified BSD                  Exp $
# $Version: 0.19.1 2015/02/28 12:33:03                   Exp $
#

# @FUNCTION: Argument field helper
# @ARG: <var> <var> <char> <int> <opt>
arg() {
	eval ${1}=$(echo "$2" | cut -d$3 -f${4:-:} $5)
}

# @FUNCTION: Print begin message to stdout
# @ARG: <msg>
begin() {
	local prefix=${name:+"$CLR_MAG[$CLR_RST $CLR_BLU$name$CLR_RST: $CLR_MAG]$CLR_RST"}
	echo -en " $prefix $@"
}

# @FUNCTION: Print end message to stdout
# @ARG: <ret> [<msg>]
end() {
	local suffix
	case "$1" in
		(0) suffix="$CLR_BLU[$CLR_RST ${CLR_GRN}Ok${CLR_RST} $CLR_BLU]$CLR_RST";;
		(*) suffix="$CLR_YLW[$CLR_RST ${CLR_RED}No${CLR_RST} $CLR_YLW]$CLR_RST";;
	esac
	shift
	echo -en " $@ $suffix\n"
}

# @FUNCTION: Colors handler
eval_colors() {
	[ -t 1 ] && yesno "${COLOR:-Yes}" || return
	local BLD='1;' ESC='\e[' FGD='3' clr
	for clr in 0:BLK 1:RED 2:GRN 3:YLW 4:BLU 5:MAG 6:CYN 7:WHT; do
		eval CLR_${clr#*:}="'$ESC$BLD$FGD${clr%:*}m'"
	done
	CLR_RST="${ESC}0m"
}

# @FUNCTION: Print message to stdout
# @ARG: <msg>
info() {
	local prefix=${name:+" $CLR_MAG$name:$CLR_RST"}
	echo -e " ${CLR_BLU}*$CLR_RST$prefix $@"
}

# @FUNCTION: Print message to stderr
# @ARG: <msg>
error() {
	local prefix=${name:+" $CLR_YLW$name:$CLR_RST"}
	echo -e " ${CLR_RED}*$CLR_RST$prefix $@" >&2
}

# @FUNCTION: Printing message handler
# @ARG: [-e|-i|-c <OPT>] <msg>
msg() {
	local _opt _msg _clr

	while [ $# -ge 1 ]; do
		case "$1" in
			(-e|-i) _opt="$1";;
			(-c) _opt="$1" _clr="$2"; shift;;
			(--) ;;
			(*) _msg="$@"; break;;
		esac
		shift
	done
	case "$_opt" in
		(-e) error "${_msg}";;
		(-i) info  "${_msg}";;
		(-c) eval echo -e "\" \$CLR_${_clr}>>>$CLR_RST ${_msg}\"";;
	esac
	$SPLASHD && debug splashd_cmd "set message $_msg" && debug splashd_cmd "repaint"
}

# @FUNCTION: Command exec handler
# @ARG: [-d|-e|-i] <msg>
debug() {
	local _cmd _opt _ret

	while [ $# -ge 1 ]; do
		case $1 in
			(-d|-e|-i) _opt="$1"
			     shift;;
			(--) shift;;
			(*) _cmd="$@"
			     break;;
		esac
	done
	eval $_cmd
	_ret=$?
	echo "[$_ret]: $_cmd" >>$LOGFILE

	if [ ! "$_ret" ]; then
		case $_opt in
			(-d)    die       "${_msg:-cmd: $_cmd}";;
			(-e|-i) msg $_opt "${_msg:-cmd: $_cmd}";;
		esac
	fi
	return "$_ret"
}

# @FUNCTON: Rescue SHell helper
rsh() {
	if $SPLASHD; then
		debug openvt -c${CONSOLE:8:1} $sh -aim 0<$CONSOLE 1>$CONSOLE 2>&1
	elif bck setsid; then
		debug setsid $sh -aim 0<$CONSOLE 1>$CONSOLE 2>&1
	else
		debug $sh -aim 0<$CONSOLE 1>$CONSOLE 2>&1
	fi
}

# @FUNCTION: Yes or No helper
yesno() {
	case "${1:-NO}" in
	(0|[Dd][Ii][Ss][Aa][Bb][Ll][Ee]|[Oo][Ff][Ff]|[Ff][Aa][Ll][Ss][Ee]|[Nn][Oo])
		return 1;;
	(1|[Ee][Nn][Aa][Bb][Ll][Ee]|[Oo][Nn]|[Tt][Rr][Uu][Ee]|[Yy][Ee][Ss])
		return 0;;
	(*)
		return 2;;
	esac
}

# @FUNCTION: Binary ChecK helper
# @ARG: <bin>
bck() {
	local _cmd
	for _cmd; do
		type -p $_cmd 1>$NULL 2>&1 || return
	done
}

# @FUNCTION: BusyBox Applets ChecK
ack() {
	local _line _list=$CONFDIR/busybox.applets
	[ -f $_list ] || busybox --list-full >$_list

	while read _line; do
		type -p ${_line#*/} >$NULL 2>&1 || ln -s /bin/busybox /$_line
	done <$_list
}

# @FUNCTION: Hook/Script execution helper
# @ARG: <hook>
dohook() {
	begin "exec: $sh -aex $1..."
	debug $sh -aex $1
	end "$?"

	if [ -f /run/env ]; then
		while read line; do
			export $line
		done </run/env
		rm -f /run/env
	fi
	[ -f /run/${1##*/}.pid ] && rm -f /run/${1##*/}.pid && debug die
	exec 0<$CONSOLE 1>$CONSOLE 2>&1	
}

# @FUNCTION: Rmmod handler
# @ARG: <module(s)|group>
_rmmod() {
	if [ -f "$CONFDIR/$1" ]; then
		while read _mod; do 
			debug rmmod -q $_mod
		done <$CONFDIR/$1
	else
		rmmod -q $*
	fi
}

# @FUNCTION: Modprobe handler
# @ARG: <module(s)|group>
_modprobe() {
	if [ -f "$CONFDIR/$1" ]; then
		while read _mod; do 
			debug modprobe -q $_mod
		done <$CONFDIR/$1
	else
		modprobe -q $*
	fi
}

# @FUNCTION: Kernel cmdline handler
# @ARG: <arg>
_getopt() {
	local _arg _cmd
	for _arg in $*; do
		for _cmd in $(cat /proc/cmdline); do
			[ "${_cmd%%=*}" = "$_arg" ] && export $_cmd && break
		done
	done
}

# @FUNCTION: Splash commands handler
# @ARG: <cmd>
splashd_cmd() {
	echo "$@" >$SPLASH_FIFO
}

# @FUNCTION: Stop splash
splashd_stop() {
	$SPLASHD && SPLASHD=false || return
	debug splashd_cmd "exit"
	export CONSOLE=/dev/console
	exec 0<$CONSOLE 1>$CONSOLE 2>&1
}

# @FUNCTION: Read helper with Rescue Shell
# @ARG: <var>
shread() {
	local _buffer

	while read _buffer; do
		case "$_buffer" in
			([Rr][Ss][Hh]|[Ss][Hh]|[Ss][Hh][Ee][Ll][Ll]|[Rr][Ee][Ss][Cc][Uu][Ee]|[Ss][Hh])
				die;;
			(*) eval ${1:-SHR}="$_buffer"; break;;
		esac
	done
}

# @FUNCTION: BLocK device handler
# @ARG: <dev|(part of)uuid|(part of)label>
blk() {
	local _asw _blk=$(blkid | grep "$1" | cut -d: -f1)
	
	if ! [ -n "$_blk" -a -b "$_blk" ]; then
		msg -i "Insert $1 block device"
		sleep 1
		_blk=$(blkid | grep "$1" | cut -d: -f1)

		while ! [ -n "$_blk" -a -b "$_blk" ]; do
			msg -i "Type in a valid block device e.g. \
				[ sda5 | UUID=<uuid> | LABEL=<label> ]"
			shread _asw
			_blk=$(blkid | grep "${_asw:-$1}" | cut -d: -f1)
		done
	fi
	eval ${2:-BLK}=$_blk
}

# @FUNCTION: dm-crypt LUKS Keyfile handler
# @ARG: <file>
ldk() {
	[ -b "$1" ] && return

	if ! $LBD_CRYPT; then
		local _ld="$(debug -d losetup -f)"
		debug -d losetup "$_ld" "$1"
		LBD_DEV="$_ld:$LBD_DEV"
	else
		local _ld="$1"
	fi
	debug cryptsetup luksOpen "$_ld" "$_fn" && LBD_KEY="$_fn:$LBD_KEY"
}

# @FUNCTION: Key[file/mode] handler
# @ARG: <mode:dev:file>
stk() {
	eval set -- $(echo "$1" | sed -e 's/:/ /g')
	local _fn="${3##*/}" _fp="$3" _kd="$2" _km="$1"

	case "$_km" in
		('') export KEYMODE=none; return;;
		(ldk)
		if [ -z "$LBD_CRYPT" ]; then
			[ $(cryptsetup -v | sed -nre 's/.*\.(.*)\..*/\1/p') -ge 3 ] &&
				LBD_CRYPT=true || LBD_CRYPT=false
		fi;;
	esac
	if [ "$_km" != "pwd" ]; then
		[ -n "$_kd" ] || die "device field empty"
		[ -n "$_fp" ] || die "file path field empty"

		if ! grep -q $MNTDIR /proc/mounts; then
			[ -f $CONFDIR/remdev ] && debug _modprobe remdev
			[ -b "$_kd" ] || blk "$_kd" "_kd"
			debug -d mount -n -r "$_kd" $MNTDIR
		fi
		debug -d test -f "$MNTDIR/$_fp"
	fi
	case $_km in
		(gpg) $ECK && debug -d bck gpg
		      [ -f $CONFDIR/gpg ] && debug _modprobe gpg
		      export KEYFILE="$MNTDIR/$_fp" KEYMODE=gpg    ;;
		(reg) export KEYFILE="$MNTDIR/$_fp" KEYMODE=reg    ;;
		(ldk) ldk "$MNTDIR/$_fp"
		      export KEYFILE="/dev/mapper/$_fn" KEYMODE=ldk;;
		(pwd) export KEYMODE=pwd                           ;;
		(*) die "$_km: invalid key mode"                   ;;
	esac
}

# @FUNCTION: BlocK Device handler
# @ARG: <dev> <key> [<BKD>] [<group>]
bkd() {
	debug -d test -n "$1"
	local _cut _luks _lvm _raid _name="$2"
	local _bkd _grp="${3:-1}"

	if [ $_grp -ge 2 ]; then
		eval set -- $(echo "$1" | sed -e 's/:/ /g')
		local _typ="$1" _dev="$2" _sig="$3"
		_cut=-s
	else
		local _dev="${1%%:*}"
	fi
	[ -n "$luks" ] && debug arg "_luks" "$luks" "," "$_grp" "$_cut"
	[ -n "$raid" ] && debug arg "_raid" "$raid" "," "$_grp" "$_cut"
	[ -n "$lvm"  ] && debug arg "_lvm" "$lvm" "," "$_grp" "$_cut"
	debug -d stk "$_luks"
	[ -n "$_raid" ] && debug -d mdopen "$_raid" "_bkd"
	[ -n "$_lvm" ]  && debug -d lvopen "$_dev" "$_lvm" "_bkd"
	[ -n "$KEYMODE" -a "$KEYMODE" != "none" ] && debug -d dmopen "$_dev" "_bkd"
	[ "$KEYMODE" =  "none" ] && debug -d blk "$_dev" "_bkd"

	eval ${_name:-BKD}=${_typ:+$_typ:}$_bkd${_sig:+:$_sig}
}

# @FUNCTION: Close dm-crypt mapping
# @ARG: <map>
dmclose() {
	local IFS="${IFS}:" 
	for _p in $@; do
		debug cryptsetup close ${_p%-*}
	done
}

# @FUNCTION: dm-crypt LUKS device|detached-header handler
# @ARG: <dev> <var>
dmcrypt() {
	local _asw _ldh=$1

	while ! debug cryptsetup isLuks "$_ldh"; do
		msg -i "Type in a valid cyphertext device e.g. \
			[ sda5 | UUID=<uuid> | LABEL=<label> ], or avalid detached header"
		shread _asw
		[ -e "${_asw:-$1}" ] || debug blk "${_asw:-$1}" "_ldh"
	done
	eval ${2:-DMC}=$_ldh
}

# @FUNCTION: dm-crypt LUKS device handler
# @ARG: <map-dev+header>
dmopen() {
	$ECK && debug -d bck cryptsetup
	debug _modprobe dm-crypt

	local _name="$2"
	eval set -- ${1/+/ }
	local _dev="${1#*-}" _hdr="$2" _header _map="${1%-*}"
	blk "$_dev" "_dev"

	local _ctx=/dev/mapper/$_map
	[ -b "$_ctx" ] && eval ${_name:-CTX}=$_ctx && return

	if [ -n "$_hdr" ]; then
		if [ -n "$(echo "$_hdr" | grep -E '(UUID|LABEL|sd[a-z])')" ]; then 
			blk "$_hdr" "_hdr"
			debug dmcrypt "$_hdr" "_header"
		elif [ -e "$MNTDIR/$_hdr" ]; then
			debug dmcrypt "$MNTDIR/$_hdr" "_header"
		else
			die "header not found"
		fi
		_header="--header $_header"
	else
		debug dmcrypt "$_dev" "_dev"
	fi
	local _arg="open $_dev $_map $_header"

	if [ "$KEYMODE" = "gpg" ]; then 
		mv /dev/tty /dev/bak && cp -a /dev/console /dev/tty
		local _i
		for _i in 1 2 3; do
			debug "gpg -qd \"$KEYFILE\" | cryptsetup $_arg"
		done
		rm /dev/tty && mv -f /dev/bak /dev/tty
	elif [ "$KEYMODE" = "ldk" -o "$KEYMODE" = "reg" ]; then
		debug cryptsetup $_arg -d "$KEYFILE"
	fi
	[ -b "$_ctx" ] || debug -d cryptsetup $_arg
	debug -d test -b $_ctx && eval ${_name:-CTX}=$_ctx
}

# @FUNCTION: LVM handler
# @ARG: <vg-lv> [<map-pv>]
lvopen() {
	$ECK && debug -d bck lvm
	debug _modprobe device-mapper
	local _lv="${1/-//}"

	if ! debug lvm lvchange -ay --noudevsync --sysinit "$_lv"; then
		if [ -n "$2" -a "$KEYMODE" != "none" ]; then
			local _pv="$2" IFS="${IFS}:"
			[ -f "$MNTDIR/$_pv" ] && _pv="$(cat $MNTDIR/$_pv)"
			for _p in $_pv; do
				debug dmopen "$_p"
			done
			debug lvm vgchange -ay --noudevsync  --sysinit "${1%-*}" ||
				die "Failed to open ${1}"
			debug lvm vgscan --mknodes
			KEYMODE=
		else
			die "no logical volume found"
		fi
	fi
	if [ -b "/dev/mapper/$1" ]; then
		eval ${3:-LV}=/dev/mapper/$1
	elif [ -b "/dev/$_lv" ]; then
		eval ${3:-LV}=/dev/$_lv
	else
		die "$_lv VG/LV not found"
	fi
}

# @FUNCTION: RAID handler
# @ARG: <md<n>-opt>
mdopen() {
	local _devices _dev="${1%+*}" _opt="${1#*+}" _set _uuid
	[ "${_dev/dev}" != "$_dev" ] || _dev=/dev/$_dev
	[ -b "$_dev" ] && eval ${2:-MD}=$_dev && return

	case "$_opt" in
		([Uu][Uu][Ii][Dd]*) _uuid="$_opt"        ;;
		(/dev/sd*[1-9])  _devices="$_opt"        ;;
		(sd*[1-9])       _devices="/dev/$_opt"   ;;
		(*-*[1-9])       _devices="/dev/sd$_opt" ;;
		(asr*|ddf*|hpt*|isw*|jmicron*|lsi*|nvidia*|pdc*|sil*|via*|dos*)
		                     _set="$_opt"        ;;
	esac
	if [ -n "$_uuid" -o -n "$_devices" ]; then
		$ECK && debug -d bck mdadm
		debug _modprobe raid
	
		if [ -n "$_uuid" ]; then
			echo ARRAY $_dev $_uuid >>/etc/mdadm.conf
		else
			echo ARRAY $_dev devices="$_devices" >>/etc/mdadm.conf
		fi
		debug mdadm --assemble ${_uuid:+-u${_uuid#*=}} -c/etc/mdadm.conf $_dev
	else
		$ECK && debug -d bck dmraid
		debug _modprobe dm-raid

		local _f _s
		for _f in $(echo "$_opt" | sed 's/:/ /g'); do
			_set="$_set $(dmraid -s -c $_f)"
		done
		for _s in ${_dev##*/} $_set; do
			debug dmraid -ay -i -I $_s
		done
	fi
	debug -d test -b $_dev
	eval ${2:-MD}=$_dev
}

# @FUNCTION: (AUFS+SquashFS) Squashed-dir mounter
# @ARG: <opt>
squashd() {
	local _squashdir="${1%%:*}" _squashd
:	${_squashdir:=aufs}
	[ "${_squashdir#/}" = "$_squashdir" ] || _squashdir="${_squashdir#/}"
	eval set -- $(echo "${1#*:}" | sed -e 's/:/ /g')

	for _arg; do
		case "$1" in
			(+[Ss]|+[Ss][Yy][Ss]|+[Ss][Yy][Ss][Tt][Ee][Mm])
				_squashd="usr bin sbin $_squashd"
				shift;;
			(+[Ll]|+[Ll][Oo][Cc][Aa][Ll])
				_squashd="var/cache/edb var/db var/lib/layman $_squashd"
				shift;;
			(*)
				_squashd="$1 $_squashd"
				shift;;
		esac
	done

	debug -d test -d $NEWROOT/$_squashdir
	debug _modprobe squashd
	cd $NEWROOT

	local _base _dir
	for _dir in $_squashd; do
		[ "${_dir#/}" = "$_dir" ] || _dir="${_dir#/}"
		_base="$_squashdir/$_dir"

		debug -d test -f $_base.squashfs || continue
		debug mkdir -p -m 0755 $_base/rw $_base/rr $_dir

		grep -q aufs:$_dir /proc/mounts && continue
		if ! grep -q $_base/rr /proc/mounts; then
			debug -d mount -t squashfs -o nodev,loop,ro $_base.squashfs \
				$_base/rr || continue
		fi
		mount -t aufs -o nodev,udba=reval,br:$_base/rw:$_base/rr aufs:/$_dir $_dir
	done
}

# @FUNCTION: FileSystem mounter
# @ARG: <dir|dev>
fsmount() {
	local _fs _dev _mpt _opt _x _y _z IFS="${IFS}:"
	local name=FSmount _tab=/etc/fstab
	[ -f $NEWROOT$_tab ] || die "no $_tab file found"

	for _x in $@; do
		_y="$(grep $_x $NEWROOT$_tab)"

		if [ -n "$_y" ]; then
			eval set -- $_y
			_fs="$3" _dev="$1" _mpt="$2" _opt="$3"
		else
			msg -e "$_x not found in $_tab"
			continue
		fi
		blk "$_dev" "_dev"
		debug -d test -b $_dev
		[ -d $NEWROOT/$_mpt ] || mkdir -p $NEWROOT/$_mpt
		debug -d mount -t$_fs ${_opt:+-o$_opt} $_dev $NEWROOT/$_mpt
	done
}

#
# vim:fenc=utf-8:ft=sh:ci:pi:sts=0:sw=4:ts=4:
#
